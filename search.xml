<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>API函数的调用过程（3环部分）</title>
    <url>/2022/03/25/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E9%83%A8%E5%88%86%EF%BC%89/</url>
    <content><![CDATA[<p>保护模式暂时告一段落了，接下来开始API函数调用的学习，来一步步分析Windows在调用API的过程中到底做了些什么事，函数到底是如何实现的。</p>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><ol>
<li><p>Application Programming Interface，简称API函数</p>
</li>
<li><p>Windows有多上万个Api，主要存放在 <strong>C:\WINDOWS\system32</strong> 下面所有的dll中</p>
</li>
<li><p>几个重要的DLL</p>
<ul>
<li>Kernel32.dll：最核心的功能模块， 比如管理内存、进程和线程相关的函数等。</li>
<li>User32.dll：是Windows用户界面相关应用程序接口，如创建窗口和发送消息等。</li>
<li>GDI32.dll：全称是Graphical Device Interface（图形设备接口），包含用于画图和显示文本的函数。例如，要显示一个程序窗口，就调用了其中的函数来画这个窗口。</li>
<li>Ntdll.dll：大多数API都会通过这个DLL进入内核（0环）。</li>
</ul>
</li>
</ol>
<h2 id="分析ReadProcessMemory"><a href="#分析ReadProcessMemory" class="headerlink" title="分析ReadProcessMemory"></a>分析ReadProcessMemory</h2><p>为了能够直观的了解API的调用过程，我们来分析一个Windows API函数，ReadProcessMemory，这个API函数位于Kernel32.dll，功能是读取指定进程的内存，打开IDA我们来看看它都做了些什么。</p>
<h3 id="ReadProcessMemory"><a href="#ReadProcessMemory" class="headerlink" title="ReadProcessMemory"></a>ReadProcessMemory</h3><p>在Kernel32.dll中选择导出函数，按下Ctrl+F，然后搜索ReadProcessMemory</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-17-30-1dbf53b9991b0ad65406a70f208001df-rpmFind-4faade.png"></p>
<p>找到后进入函数主体A</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-17-49-85e4e9760ea99f91609f983d45124c7c-rpmBody-2473f7.png"></p>
<p>我们可以看到，ReadProcessMemory函数总体分为3个部分:</p>
<p>首先是参数的压栈，其次调用了一个函数NtReadVirtualMemory，接着就开始处理函数的返回值了，可以发现，真正读取内存的功能并不是在ReadProcessMemory中实现的，所以我们需要进一步去查看NtReadVirtualMemory。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-37-50-01be1619a3b7a7a5cbd3e109c39abcb9-rpmExtrn-18a642.png"></p>
<p>把鼠标放在NtReadVirtualMemory上，发现该函数是外部函数，不属于Kernel32.dll，所以我们得去Kernel32.dll的导入函数中找一下这个函数属于哪个dll。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-38-29-e007649479632221e43b2e89d34875ff-rpmImports-35d87e.png"></p>
<p>可以见得，NtReadVirtualMemory属于Ntdll.dll，接下来进入NtReadVirtualMemory继续分析。</p>
<h3 id="NtReadVirtualMemory"><a href="#NtReadVirtualMemory" class="headerlink" title="NtReadVirtualMemory"></a>NtReadVirtualMemory</h3><p>找到函数主体的步骤和上面一样，不再赘述。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-38-52-486d3c54d922b403235e140be345feb4-nrvm-5d5397.png"></p>
<p>NtReadVirtualMemory的函数主体部分只有4行，其中最关键的是前两行：</p>
<ul>
<li>mov eax, 0BAh：这一步给eax赋值了一个编号，这个编号的作用是在进入0环后，找到真正需要调用的函数。<strong>记住，这个编号存在eax中。</strong></li>
<li>mov edx, 7FFE03000h：这一步同样关键，这是一个函数地址。它决定了进入0环的方式（具体在下一篇中会详细分析），同样，也要记住edx存了这个值。</li>
</ul>
<p>经过简单的分析，可以发现，在3环层面上， 并没有真正实现函数的功能，<strong>API函数的实现，大部分都在0环</strong>（只有少部分函数是在3环实现）。拿ReadProcessMemory来说，只是相对于0环给上层提供的一个接口，通过这个接口，我们可以实现读取指定地址的内存</p>
<h2 id="重写API函数"><a href="#重写API函数" class="headerlink" title="重写API函数"></a>重写API函数</h2><p>现在我们知道，API函数的真正实现实际上是在底层（0环），3环上的API函数实际上只是起到一个接口的作用。那么我们可以自己重写3环的API，自己去调用0环函数，这样做的好处是，可以避免3环恶意挂钩（例如有黑客Hook了OpenFile函数，每次我们调用OpenFile时，黑客就知道我们打开了什么文件，如果重写API函数，黑客就无法通过Hook OpenFile函数来获取我们打开的文件内容，除非黑客在0环动手脚）</p>
<h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-45-56-c89ab47827294f9f04f53f313f808354-overwrite-4a98f9.png"></p>
<p>实现的功能大致如此，读取变量a所在地址的内容，将内容改写后，再写入该地址，先用Windows API提供的ReadProcessMemory和WriteProcessMemory实现一遍。可以看到，原本变量a的值为0x123，随后被修改成了0x567</p>
<h3 id="重写ReadProcessMemory"><a href="#重写ReadProcessMemory" class="headerlink" title="重写ReadProcessMemory"></a>重写ReadProcessMemory</h3><p>这里以ReadProcessMemory为例，在先前的分析中， 我们知道ReadProcessMemory仅仅做了参数压栈的工作，而NtReadVirutalMemory先给eax赋值了一个编号，接着给edx赋了一个函数地址，并调用此函数，然后平衡堆栈。所以我们只需要将这些功能组合一下即可：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> _stdcall <span class="title">MyReadProcessMemory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">				HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">				LPCVOID lpBaseAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">				LPVOID lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">				DWORD nSize,</span></span></span><br><span class="line"><span class="params"><span class="function">				LPDWORD lpNumberOfBytesRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	_asm &#123;</span><br><span class="line">		<span class="comment">//ReadProcessMemory</span></span><br><span class="line">		lea eax, [ebp+<span class="number">0x14</span>]</span><br><span class="line">		push eax            <span class="comment">//lpNumberOfBytesRead</span></span><br><span class="line">		push [ebp+<span class="number">0x14</span>]     <span class="comment">//nSize</span></span><br><span class="line">		push [ebp+<span class="number">0x10</span>]     <span class="comment">//lpBuffer</span></span><br><span class="line">		push [ebp+<span class="number">0xC</span>]      <span class="comment">//lpBaseAddress</span></span><br><span class="line">		push [ebp+<span class="number">0x8</span>]      <span class="comment">//hProcess</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//NtReadVirtualMemory</span></span><br><span class="line">		mov eax, <span class="number">0xBA</span></span><br><span class="line">		mov edx, <span class="number">0x7FFE0300</span></span><br><span class="line">		call dword ptr [edx]</span><br><span class="line">		add esp, <span class="number">0x14</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，仅仅这样做还不够，这样虽然编译能过，但是执行会报错。因为在ReadProcessMemory中调用NtReadVirutalMemory用了call语句，<strong>call语句的使用会导致返回地址压栈</strong>，也因此，我们重写的API函数在执行这条语句时，<strong>esp处的值为hProcess</strong>，而Windows在执行这条语句时，[esp+4]处的值才是hProcess！如果这里不做修改，后面函数返回时，堆栈会不平衡，因此我们需要手动修改一下堆栈：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-47-14-754dc6c0d711ce2855a9a820523e24a3-modifyStack-395911.png"></p>
<p>增加了这两行后，我们自己重写的ReadProcessMemory就算完成了。同理，WriteProcessMemory也是如此。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-21-48-02-0c391b24435e061576f28394f4a16e10-owResult-51b40b.png"></p>
<p>可以看到，我们使用了自己重写的API函数，但是实现了同样的功能。同理，别的函数也可以通过重写，从而防止3环的恶意挂钩。</p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include </span><br><span class="line">void _stdcall MyReadProcessMemory(</span><br><span class="line">				HANDLE hProcess,</span><br><span class="line">				LPCVOID lpBaseAddress,</span><br><span class="line">				LPVOID lpBuffer,</span><br><span class="line">				DWORD nSize,</span><br><span class="line">				LPDWORD lpNumberOfBytesRead)</span><br><span class="line">&#123;</span><br><span class="line">	_asm &#123;</span><br><span class="line">		//ReadProcessMemory</span><br><span class="line">		lea eax, [ebp+0x14]</span><br><span class="line">		push eax                        //lpNumberOfBytesRead</span><br><span class="line">		push [ebp+0x14]                 //nSize</span><br><span class="line">		push [ebp+0x10]                 //lpBuffer</span><br><span class="line">		push [ebp+0xC]                  //lpBaseAddress</span><br><span class="line">		push [ebp+0x8]                  //hProcess</span><br><span class="line">		</span><br><span class="line">		//NtReadVirtualMemory</span><br><span class="line">		sub esp, 0x4		            //Call NtReadVirtualMemory</span><br><span class="line">		mov eax, 0xBA</span><br><span class="line">		mov edx, 0x7FFE0300</span><br><span class="line">		call dword ptr [edx]</span><br><span class="line">		add esp, 0x18</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void _stdcall MyWriteProcessMemory(</span><br><span class="line">				HANDLE hProcess,</span><br><span class="line">				LPVOID lpBaseAddress,</span><br><span class="line">				LPVOID lpBuffer,</span><br><span class="line">				DWORD nSize,</span><br><span class="line">				LPDWORD lpNumberOfBytesWritten)</span><br><span class="line">&#123;</span><br><span class="line">	_asm &#123;</span><br><span class="line">		//WriteProcessMemory</span><br><span class="line">		lea eax, [ebp+0x8]                //hProcess</span><br><span class="line">		push eax                          //lpNumberOfBytesRead</span><br><span class="line">		push [ebp+0x14]                   //NumberOfBytesToWrite</span><br><span class="line">		push [ebp+0x10]                   //lpBuffer</span><br><span class="line">		push [ebp+0xC]                    //lpBaseAddress</span><br><span class="line">		push [ebp+0x8]                    //hProcess</span><br><span class="line">		</span><br><span class="line">		//NtWriteVirtualMemory</span><br><span class="line">		sub esp, 0x4                      //Call NtWriteirtualMemory</span><br><span class="line">		mov eax, 0x115</span><br><span class="line">		mov edx, 0x7FFE0300</span><br><span class="line">		call dword ptr [edx]</span><br><span class="line">		add esp, 0x18</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int a = 0x123;</span><br><span class="line">	int buffer = 0;</span><br><span class="line">	printf(&quot;Before: a=%x&quot;, a);</span><br><span class="line">	MyReadProcessMemory(GetCurrentProcess(), &amp;a, &amp;buffer, 4, NULL);</span><br><span class="line">    // printf(&quot;%x&quot;, buffer);</span><br><span class="line"></span><br><span class="line">	buffer = 0x567;</span><br><span class="line">	getchar();</span><br><span class="line">	MyWriteProcessMemory(GetCurrentProcess(), &amp;a, &amp;buffer, 4, NULL);</span><br><span class="line">	printf(&quot;After: a=%x\n&quot;, a);</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于API函数的调用过程，我们对三环的部分有了一定的了解，发现，大部分API的实现都是在0环，接下来的文章中，我们就跟进去，找找API函数在0环中的实现在哪。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
        <tag>x86</tag>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title>10-10-12分页</title>
    <url>/2022/03/18/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/10-10-12%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<blockquote>
<p>保护模式下内存管理方式分为两种，段与页。</p>
<p>前面的篇章中，简要介绍了段的知识，今天就来和大家聊聊页的知识，页是保护模式中更为重要的一环，随着系统进入32-Bit，段的作用明显降低了，取而代之的则是在段的基础上，更为细分的页。</p>
</blockquote>
<h2 id="段与页"><a href="#段与页" class="headerlink" title="段与页"></a>段与页</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/segAndPage.png"></p>
<p>这是Intel白皮书中介绍关于段与页的概要图，经过段的学习，可以很容易的理解左半部分，这是一个根据所提供的<strong>有效地址（图中Offset）</strong>以及段寄存器中确定的基址，锁定线性地址空间中的某个<strong>线性地址（Linear Address）</strong>的过程。而右半部分，则是利用了页的功能，通过拆分<strong>线性地址</strong>，一步步转化成了<strong>物理地址</strong>。</p>
<p>上述提到了3个概念，有效地址，线性地址以及物理地址，文字叙述会让人混淆，我们来看一条语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">; 0x12345678是有效地址</span><br><span class="line">; ds.Base + 0x12345678是线性地址</span><br><span class="line">mov dword ptr ds:[0x12345678], 0x123</span><br></pre></td></tr></table></figure>

<p>这都非常好理解，那什么是物理地址呢？考虑这样一个问题，掌握3环知识的小伙伴们知道每个进程都有4GB的内存空间，这时如果有一个进程A，给会进行一个操作，给<code>ds.Base + 0x12345678</code>赋值<code>0x123</code>，还有一个进程B，同样会给<code>ds.Base + 0x12345678</code>赋值<code>0x123</code>，那么<code>ds.Base + 0x12345678</code>处的位置到底是哪个值呢？还是两者都不是呢？这就涉及到了物理地址的概念。</p>
<h2 id="PDT与PTT"><a href="#PDT与PTT" class="headerlink" title="PDT与PTT"></a>PDT与PTT</h2><p>每个进程都有一个CR3的值，CR3是什么？实际之前在TSS切换时也用到了，具体等到了控制寄存器那会详细分析。简单来说，CR3被用来<strong>切换和定位当前正在使用的页表</strong>，它是一个32位的寄存器，其中高20位指向一个<strong>物理页</strong>（Windows系统上，一个页的大小是4KB，也就是4096个字节），如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/pdtAndPtt.png"></p>
<p>这图该怎么看呢？首先CR3会指向一个物理页，这个物理页又叫做<strong>页目录表（PDT）</strong>，页目录表每个元素叫做<strong>页目录表项（PDE）</strong>，页目录表项，每个4字节，所以一共有<strong>1024个</strong>页目录表项，CR3就好比一本书，PDT就是这本书的目录，PDE就是章节，这是一本有1024个章节的书（哇塞，真厚啊U•ェ•*U），这样就好理解多了。这是第一级。</p>
<p>页目录表项又指向一个第二级的表，叫做<strong>页表（PTT）</strong>，页表的大小也是4KB，页表中的每个元素叫做<strong>页表项（PTE）</strong>。页表项可以理解为书中章节的每个小节，就好比第一章里面有1024个小节，这个小节就是PTE，这1024个小节加起来，构成一个小节表，就是PTT。</p>
<p>第二级介绍完了，第三级也就好理解了，既然书中每个章节的每个小节理解了，接下来就是页码了，每个小节都会对应书中的某个页码。而这个页码，就是相当于的物理页了。这样就可以理解这张图了，就是一部部找到物理页。</p>
<h2 id="10-10-12分页"><a href="#10-10-12分页" class="headerlink" title="10-10-12分页"></a>10-10-12分页</h2><p>Windows采用三种分页方式，在32位系统上主要有10-10-12分页和2-9-9-12分页这两种方式，在64位系统上增加了9-9-9-9-12这种分页方式，后面的文章会依次介绍32位下的两种分页方式。首先从10-10-12开始。</p>
<p>首先修改C盘的boot.ini文件，将noexecute改成execute，重启虚拟机，即可使用10-10-12分页方式</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/boot.png">10-10-12分页是如何工作的呢？来看一个简单的程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0x123</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, &amp;a);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序很简单，给a赋值0x123，并查看a的地址</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/find.png"></p>
<p>而这个地址<code>0x12ff7c</code>，实际上就是前文提到的线性地址，接下来我们将这个32位的地址按照10-10-12的方式进行拆分：</p>
<ol>
<li><p>将<code>0x12ff7c</code>拆分成二进制：0000 0000 0001 0010 1111 1111 0111 1100</p>
</li>
<li><p>将这32位二进制数，按照10-10-12的方式组合：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>每部分位数</th>
<th>二进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>0000 0000 00</td>
<td>0</td>
</tr>
<tr>
<td>10</td>
<td>01 0010 1111</td>
<td>12f</td>
</tr>
<tr>
<td>12</td>
<td>1111 0111 1100</td>
<td>f7c</td>
</tr>
</tbody></table>
<ol start="3">
<li>根据Cr3找到页目录表（PDT）中的页目录表项（PDE）：</li>
</ol>
<p>首先在Windbg中执行!process 0 0指令，找到当前程序的Cr3，Cr3的值指向的就是页目录表的首地址。由于第一部分值为0，所以要查找的PDE，需要用Cr3+0*4(乘4是因为每个PDE大小是4字节)，这里注意一下，由于查找的是物理地址，所以使用的是!dd指令。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-29-26-0c66892caef6ea7fbf26de4b76cd9055-findPDE-33635a.png"></p>
<ol start="4">
<li>根据PDE找到页表（PTT）中的页表项（PTE）：</li>
</ol>
<p>上一步已经找到了PDE，PDE的值指向的是某个PTT的首地址，方法和上一步一样，用PDE中的值+12f(拆分完的第二部分)x4，就可以得到PTE，这里要注意一点，将PDE中的值代入时，<strong>后12位置0</strong>，由于后12位为属性位，在<strong>查找的过程中</strong>不起作用</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-29-46-47d90e24438239f625efc3c3a1e8305c-findPTE-ed0e73.png"></p>
<ol start="5">
<li>根据PTE确定物理地址：</li>
</ol>
<p>确定PTE后，就剩最后一步了。由于一个物理页的大小本身就是4KB，也就是2的12次方，所以当<strong>确定了前20位后也就确定了物理页</strong>，因此我们要找的内容就在<code>219da000</code>这个物理页上的某个物理地址。这个物理页的范围是<code>219da000</code>~&#96;219dafff&#96;。现在可以理解，<strong>PTE指向的是一个物理页的首地址</strong>，根据最后12位的来确定，我们要寻找的值在物理页上的偏移，也就真正的找到了这个物理地址。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-30-16-058494a946a0569de127d5cf18b45537-findPhyAddr-5aa14d.png"></p>
<p>根据实验截图，发现我们一开始存在变量a里面的<code>0x123</code>，真正存的地方在<code>0x219daf7c</code>这个物理地址的位置，这就是通过线性地址一步步的找过来的，这些工作都是CPU做的，比如当我们读取a这个地址上的值是，CPU会通过分页机制读取该物理地址的值，然后再显示出来。</p>
<h2 id="有趣的实验"><a href="#有趣的实验" class="headerlink" title="有趣的实验"></a>有趣的实验</h2><h3 id="读错值了？"><a href="#读错值了？" class="headerlink" title="读错值了？"></a>读错值了？</h3><p>有了10-10-12分页的知识，来做一个有趣的小实验</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0x123</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, &amp;a);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, *(&amp;a));</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代码非常简单，一般人认为，会先输出a的地址，然后再输出<code>0x123</code>。但有了物理页的知识，我们就可以做一些手脚了。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-31-32-11f2a7357b3af11c46877a202add96b8-modifyCode-32aab3.png"></p>
<p>很奇怪吧？为什么输出不是<code>0x123</code>，而却输出<code>0x456</code>呢？原因就在于，我们偷偷修改了变量的物理地址上的值，将原本的<code>0x123</code>改成了<code>0x456</code>，因此，CPU再次去物理页读取时，值已经发生了变化，读到了修改后的值。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-31-43-8d555eec52ae6e0d870b19d69417a22a-modifyWin-8a1832.png"></p>
<h3 id="0地址也能存值？"><a href="#0地址也能存值？" class="headerlink" title="0地址也能存值？"></a>0地址也能存值？</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, &amp;a);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	</span><br><span class="line">	*(<span class="type">int</span>*)<span class="number">0</span> = <span class="number">0x123</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;address0: %x&quot;</span>, *(<span class="type">int</span>*)<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是个显而易见运行会失败的程序，为什么？因为你给0地址赋值了，有点C&#x2F;C++开发经验的人都知道，0地址是不能存值的，为什么？因为运行不过去啊！这不扯淡嘛！你看我就运行过去了！</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-32-05-0ebea905984bbb581c352912af0b93ef-store0Code-77ecc0.png"></p>
<p>这又是为什么呢？其实0地址不能存值的原因是，没有给它挂物理页，既然没有物理页，那CPU按照分页去查的时候，就查不到了；那么只要给他挂个物理页，就可以给这个线性地址存值了，具体操作如下。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-17-22-32-48-64b85154cebf8cae111729d32a30240f-store0Win-f07c9c.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>一张页表能包含的物理页：1024*KB &#x3D; 4MB</li>
<li>10-10-12分页共有1024张页表：1024*4MB &#x3D; 4GB</li>
<li>前20位的值如果相同，那么一定在同一个物理页</li>
<li>一个PTE最多可以指向一个物理页；PTE可以没有物理页；多个PTE可以指向同一个物理页</li>
</ol>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>2-9-9-12分页</title>
    <url>/2022/03/22/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/2-9-9-12%E5%88%86%E9%A1%B5/</url>
    <content><![CDATA[<p>在前面的文章中主要介绍了10-10-12分页方式，在这种分页方式下，物理地址最多可达4GB。随着硬件发展，4GB的物理地址范围已经无法满足要求，于是Intel设计了一种新的分页方式：2-9-9-12分页（又称PAE）分页。下面就来了解一下这种分页方式是如何运作的吧。</p>
<h2 id="PAE分页"><a href="#PAE分页" class="headerlink" title="PAE分页"></a>PAE分页</h2><h3 id="为什么是2-9-9-12"><a href="#为什么是2-9-9-12" class="headerlink" title="为什么是2-9-9-12"></a>为什么是2-9-9-12</h3><p>PAE（Physical Address Extension，物理地址扩展）页，一定会涉及到2个结构，就是PDE和PTE。以PTE来说，它可以直接定位到某个物理页上的物理地址，在10-10-12分页下，由于PTE的大小是4字节(32位)，因此PTE能够寻址的范围仅有4GB。设想，若PTE有33位，那便可以寻址8GB；34位就能寻址16GB……以此类推。Intel考虑到对齐的因素，就干脆直接让PTE的长度达到64位了。这样一个PTE的大小就8字节，又因为一个PTT表的大小是4KB(4096字节)，因此原本一个PTT表里能装下1024个4字节的PTE，现在只能装下512个8字节的PTE了。2的9次方等于512，所以PTI的值为9。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-18-14-633bdc3b36aec369d0dcf755f7019467-2022-07-23-12-18-10-633bdc3b36aec369d0dcf755f7019467-pti9-7837ad-b483ab.png"></p>
<p>同理，PDI的值也为9，这样2-9-9-12中还剩下最前面的2位。</p>
<h3 id="设置PAE分页"><a href="#设置PAE分页" class="headerlink" title="设置PAE分页"></a>设置PAE分页</h3><p>设置PAE分页比较简单，进入C盘打开boot.ini文件修改启动项，将execute改成noexecute即可，然后重启虚拟机即可进入PAE分页。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-17-51-e076d16ed2da49eb0db4cd5c0b6f7b00-noexe-c54eff.png"></p>
<h3 id="PDPTE"><a href="#PDPTE" class="headerlink" title="PDPTE"></a>PDPTE</h3><p>PDPTE（Paga-Directory-Point-Table Entry）页目录指针表项，顾名思义，这是一个指向PDT表（在10-10-12分页下，Cr3指向PDT表的首地址）的元素，且位于PDPT表（PAE分页下Cr3指向PDPT表首地址）中。由于仅剩2位，所以PDPTE只有4个，同样PDPTE每项占8个字节，来看下这个结构。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-17-41-842f918e07fb96b1e51790491b8b96ee-pdpte-91792c.png"></p>
<ul>
<li>Avail：下标9~11，共3位，这是留给操作系统使用的位，CPU本身并不使用</li>
<li>Base Address：下标12~35，寻址时，低12位补0，共36位（达到36位，与PTE保持一致，寻址空间达到64GB），即PDT基址</li>
</ul>
<p>至于PCD和PWT，留到控制寄存器和TLB部分详解。</p>
<h3 id="PDE"><a href="#PDE" class="headerlink" title="PDE"></a>PDE</h3><p>PAE分页下，PDE扩展到了64位，其余属性变化不大。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-17-29-b65f3876d1e7535be86337881272f8e3-pde-0b24ef.png"></p>
<ul>
<li>PS &#x3D; 1：大页，下标35-21是大页的物理地址，低21位填0，大页的大小为2MB（10-10-12的大页为4MB），按照2MB对齐。</li>
<li>PS &#x3D; 0：下标35~12是页表（PTT）基址，低12位补0，共36位。</li>
<li>Avail：同PDPTE</li>
</ul>
<h3 id="PTE"><a href="#PTE" class="headerlink" title="PTE"></a>PTE</h3><p>与PDE一样，PAE分页下的PTE，也是扩展到了64位，其余变化不大</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-17-12-178be08faf7dea4c0b0676ebfbda2bf7-pte-f273e3.png"></p>
<p>PTE中下标35-12是物理页基址，共24位（10-10-12分页下是下标31~12，共20位），低12位补0。</p>
<p><strong>物理页基址</strong>+12位的页内偏移指向具体数据。</p>
<p>在了解这些结构后，来看一下PAE分页的大致模型</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-17-04-299c40ccb34891f34ebda7b3d2229cfe-pae-df8675.png"></p>
<h3 id="XD位"><a href="#XD位" class="headerlink" title="XD位"></a>XD位</h3><p>在Intel新系列的CPU中，在下标63的地方多了一个属性位XD位（AMD中称为NX，即No Execetion）</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-16-53-0d2b20452ece918ab65fafdd7c67665d-xd-d4b175.png"></p>
<p>我们知道段的属性有可读、可写和可执行，但是页的属性只有可读、可写。</p>
<p>当ret执行返回语句时，如果堆栈里的数据指向一个提前准备好的数据（把数据当作代码来执行，漏洞很多都是依赖这点，比如SQL注入），这个位的作用就是在硬件上实现一种保护，防止数据可执行的情况发生。</p>
<h3 id="查找物理页"><a href="#查找物理页" class="headerlink" title="查找物理页"></a>查找物理页</h3><p>PAE分页下查找对应的物理页和10-10-12差不多，拆分线性地址后，再根据PDPI、PDI、PTI偏移去找，由于每项均是8字节，所以在Windbg中使用dq指令进行查看。来看下面这个例子：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-16-40-8f808662a0511f8ba8b529c1d2488c43-find_c-8ac065.png"></p>
<p>变量a的线性地址为：0x12ff7c。按照2-9-9-12进行拆分后得到0-0-12f-f7c。接着通过Cr3一步步查找，具体如下：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-16-30-018dfa5ff657de9fdaac73d99c936461-find_w-c3a70c.png"></p>
<p>变量a的存的值为0x123，通过拆分线性地址，成功在找到变量a对应的物理地址。</p>
<h2 id="0地址挂物理页"><a href="#0地址挂物理页" class="headerlink" title="0地址挂物理页"></a>0地址挂物理页</h2><p>在学习10-10-12分页时，通过0地址挂物理页的实验，加深对物理页的理解，这里我们通过这个实验进一步熟悉PAE分页。</p>
<p>先运行程序，发现访问违例，运行失败</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-16-12-ed8fb02f6356fe4e03df55be63f84f0f-0before-d4abd4.png"></p>
<p>查看0地址对应的物理页，发现物理页是空的。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-16-03-e4bb2237ad4337e8ebf3dd835e192f78-0page-4e8268.png"></p>
<p>然后查看局部变量a对应的物理页，并将a对应的物理页挂到0的位置（注意，挂物理页时，用两次!ed指令而不是!eq指令）</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-15-54-6f857bb8522ea41ce41a0c57e0bcf7e2-apage-0b4b8f.png"></p>
<p>接着运行程序发现可以正确的打印出0地址上的内容</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-15-43-f79a318e96e3b070a82e32cbdbdd01ed-0after-b49e16.png"></p>
<h2 id="PAE分页下PDT-x2F-PTT的基址"><a href="#PAE分页下PDT-x2F-PTT的基址" class="headerlink" title="PAE分页下PDT&#x2F;PTT的基址"></a>PAE分页下PDT&#x2F;PTT的基址</h2><p>新增加的结构，PDPTE，并没有R&#x2F;W位，US位等属性，真正决定物理页属性的还是PDE和PTE。相比10-10-12分页可以通过PDT&#x2F;PTT基址修改物理页属性，在PAE分页下同样可以做到，这部分我们来研究下PAE分页下PDT和PTT的基址。</p>
<h3 id="逆向分析MmIsAddressValid"><a href="#逆向分析MmIsAddressValid" class="headerlink" title="逆向分析MmIsAddressValid"></a>逆向分析MmIsAddressValid</h3><p>在前一篇文章中我们分析了10-10-12分页下的MmIsAddressValid函数，它在找到PDE&#x2F;PTE后会判断下标为0(P位)和下标为7(PDE对应PS位，PTE对应PAT位)的位置的值，进行一些处理工作。而这个函数找到PDE&#x2F;PTE的过程就使用了PDT&#x2F;PTT的基址。这次通过分析PAE分页下的MmIsAddressValid函数，来找到PAE分页下PDT&#x2F;PTT基址。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-15-26-e362b9223c1c881f7cc4c56ec6b10785-miav-84b105.png"></p>
<p>先分析查找PDE的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80511987 8b4d08          mov     ecx,dword ptr [ebp+8]     ; 获取参数</span><br><span class="line">8051198a 56              push    esi	</span><br><span class="line">8051198b 8bc1            mov     eax,ecx</span><br><span class="line">8051198d c1e812          shr     eax,12h                   ; 右移18位</span><br><span class="line">80511990 bef83f0000      mov     esi,3FF8h	</span><br><span class="line">80511995 23c6            and     eax,esi                   ; 进行与运算，余下11位有效位</span><br><span class="line">80511997 2d0000a03f      sub     eax,3FA00000h             ; 相当于add eax, 0xC0600000</span><br><span class="line">8051199c 8b10            mov     edx,dword ptr [eax]       ; 取PDE低四字节</span><br><span class="line">8051199e 8b4004          mov     eax,dword ptr [eax+4]     ; 取PDE高四字节</span><br><span class="line">805119a1 8945fc          mov     dword ptr [ebp-4],eax     ; 高四字节保存到局部变量</span><br><span class="line">805119a4 8bc2            mov     eax,edx</span><br><span class="line">805119a6 57              push    edi                       ; 保存edi原本的值</span><br><span class="line">805119a7 83e001          and     eax,1                     ; 保留P位的值</span><br><span class="line">805119aa 33ff            xor     edi,edi</span><br><span class="line">805119ac 0bc7            or      eax,edi</span><br></pre></td></tr></table></figure>

<ul>
<li>右移18位后，进行了一次与运算，保留的位相当于PDPI x 4KB + PDI x 8（看不明白的可以<a href="https://happy1wawayu.github.io/2022/03/21/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid/#%E5%B7%A7%E5%A6%99%E7%9A%84%E4%B8%8E%E8%BF%90%E7%AE%97">参考这篇</a>）</li>
<li>sub eax, 0x3FA00000和add eax, 0xC0600000，因此可以推测，<strong>PAE分页下PDT的基址为0xC0600000</strong></li>
</ul>
<p>接着分析查找PTE的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">805119c3 c1e909          shr     ecx,9                          ; 右移9位</span><br><span class="line">805119c6 81e1f8ff7f00    and     ecx,7FFFF8h                    ; 进行与运算，余下20位有效位</span><br><span class="line">805119cc 8b81040000c0    mov     eax,dword ptr [ecx-3FFFFFFCh]  ; 相当于mov eax, [ecx+0xC0000004]</span><br><span class="line">805119d2 81e900000040    sub     ecx,40000000h                  ; 相当于add ecx, 0xC0000000</span><br><span class="line">805119d8 8b11            mov     edx,dword ptr [ecx]            ; 取PTE低四字节</span><br><span class="line">805119da 8945fc          mov     dword ptr [ebp-4],eax          ; 将PTE高四字节保存至局部变量</span><br><span class="line">805119dd 53              push    ebx                            ; 保存ebx原本的值</span><br><span class="line">805119de 8bc2            mov     eax,edx	</span><br><span class="line">805119e0 33db            xor     ebx,ebx	</span><br><span class="line">805119e2 83e001          and     eax,1                          ; 保留P位的值</span><br><span class="line">805119e5 0bc3            or      eax,ebx</span><br><span class="line">805119e7 5b              pop     ebx</span><br></pre></td></tr></table></figure>

<ul>
<li>重点还是在与运算这，右移9位后跟0x7FFFF8进行与运算，相当于PDPI x 2MB + PDI x 4KB + PTI x 8</li>
<li>sub ecx，0x40000000相当于add ecx, 0xC0000000，可以推测，<strong>PAE分页下PTT的基址仍然为0xC0000000</strong></li>
</ul>
<h3 id="公式总结"><a href="#公式总结" class="headerlink" title="公式总结"></a>公式总结</h3><p>根据MmIsAddressValid函数，可以得到PAE分页下<strong>PDT和PTT的基址分别为0xC0600000和0xC0000000</strong>。</p>
<p>我们可以采纳MmIsAddressValid的方法总结出找到任意一个PDE &#x2F;PTE的公式：</p>
<ol>
<li>利用MmIsAddressValid内的手法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pPDE = (int*)(0xc0600000 + ((addr &gt;&gt; 18) &amp; 0x3ff8))</span><br><span class="line">pPTE = (int*)(0xc0000000 + ((addr &gt;&gt; 9) &amp; 0x7ffff8))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过拆分线性地址</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pPDE = (int*)(0xc0600000 + (PDPTI&lt;&lt;12) + (PDI&lt;&lt;3))</span><br><span class="line">pPTE = (int*)(0xc0000000 + (PDPTI&lt;&lt;21) + (PDI&lt;&lt;12) + (PTI&lt;&lt;3))</span><br></pre></td></tr></table></figure>

<h2 id="修改常量区"><a href="#修改常量区" class="headerlink" title="修改常量区"></a>修改常量区</h2><p>在10-10-12分页学习的时候，我们知道通过修改物理页属性，可以使得程序能够修改常量区里的内容。并且在<a href="https://happy1wawayu.github.io/2022/03/20/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/">基址小实验</a>那篇中，通过代码实现了修改常量区的操作，利用了基址，从而可以在代码中通过线性地址找到PDE和PTE。这里，在PAE分页下，重做一遍那个实验，原理一样，就不在此赘述了。</p>
<p>首先，直接修改位于常量区的“protect”失败</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-13-39-9e8c4c7f4c98db656730151cacc3d497-constBefore-cd4b4f.png"></p>
<p>这里采用拆分线性地址的方式计算PDE&#x2F;PTT的具体位置，拆分“protect”所在的线性地址0x423034 -&gt; 0-2-0x23-0x34</p>
<p>接着在裸函数里实现通过基址修改PDE&#x2F;PTE（执行这部分要先提权，然后在调用门内实现）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp = *(int*)(0xC0600000 + 0*0x1000 + 2*0x8);</span><br><span class="line">temp = temp|0x2;	//将R/W位置1</span><br><span class="line">*(int*)(0xC0600000 + 0*0x1000 + 2*0x8) = temp;</span><br><span class="line">temp = *(int*)(0xC0000000 + 0 + 2*0x1000 + 0x23*0x8);</span><br><span class="line">temp = temp|0x2;	//将R/W位置1</span><br><span class="line">*(int*)(0xC0000000 + 0 + 2*0x1000 + 0x23*0x8) = temp;</span><br></pre></td></tr></table></figure>

<p>在做这部分实现时，我踩了一个大坑：temp &#x3D; temp|0x2，在执行这条语句时，<strong>运算符”|”的两侧千万不能加空格</strong>，不然就死机了，我也不知道是什么原因，只要运算的结果对原操作数有影响，就会死机，若没有影响，会继续执行，这个坑也导致我停顿了好一会。</p>
<p>修改完PDE&#x2F;PTE的属性后，执行代码，便可以成功修改常量区的内容。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-13-20-668fa9bffdf84b9bfad9ff4dbf6b6474-constAfter-7ef90b.png"></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">int temp;</span><br><span class="line"></span><br><span class="line">__declspec(naked) void ModifyConst() &#123;</span><br><span class="line">	_asm &#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	temp = *(int*)(0xC0600000 + 0*0x1000 + 2*0x8);</span><br><span class="line">	temp = temp|0x2;</span><br><span class="line">	*(int*)(0xC0600000 + 0*0x1000 + 2*0x8) = temp;</span><br><span class="line">	temp = *(int*)(0xC0000000 + 0 + 2*0x1000 + 0x23*0x8);</span><br><span class="line">	temp = temp|0x2;</span><br><span class="line">	*(int*)(0xC0000000 + 0 + 2*0x1000 + 0x23*0x8) = temp;</span><br><span class="line"></span><br><span class="line">	_asm &#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	char* str = &quot;protect&quot;;</span><br><span class="line">	char buffer[] = &#123;0, 0, 0, 0, 0x4B, 0&#125;;</span><br><span class="line">	printf(&quot;addr: %x&quot;, str);</span><br><span class="line">	getchar();</span><br><span class="line">	_asm &#123;</span><br><span class="line">		call fword ptr buffer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*str = &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line">//	printf(&quot;%x\n&quot;, temp);</span><br><span class="line">	printf(&quot;str: %s&quot;, str);</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>PAE分页下，整体流程和10-10-12分页差别不大，在理解了10-10-12分页的基础上，学习PAE分页是不困难的，个人觉得如果能真正理解PDT&#x2F;PTT基址的原理和使用方法，对PAE分页能掌握的更好。PDT的基址C0600000还是很好理解的，但是PTT的就有点困难了，尽管计算上的结果是正确的，但是在拆分后带入Cr3跟进时，可能会踩一些小坑。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>PDE_PTE属性（部分）</title>
    <url>/2022/03/19/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/PDE_PTE%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>上一篇文章中了解了PDE和PTE，这一篇就来了解一下PDE和PTE的属性。</p>
<h2 id="物理页的属性"><a href="#物理页的属性" class="headerlink" title="物理页的属性"></a>物理页的属性</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-25-46-9b5dc5ae7b30714e111bdf929c88d08d-attr-2149b9.png"></p>
<p>一上来看这张图，肯定是一脸懵逼的。先从行开始看，第一行是关于CR3寄存器的，这部分留到控制寄存器的章节再分析。接下来三行是不同类型PDE的，最后两行是PTE的。其中PDE和PTE有很多属性是重合的。而物理页的属性，就是有PDE和PTE共同决定的。计算方法是将相同属性位的值进行与运算。</p>
<p>物理页的属性 &#x3D; PDE属性 &amp; PTE属性</p>
<h2 id="P位"><a href="#P位" class="headerlink" title="P位"></a>P位</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-25-58-913745745e113b72fb181b8d6862b42a-p-8d5c7d.png"></p>
<p>首先来看P（Present）位：存在位。PDE与PTE的P位均位1时，物理页有效；其余情况，物理页不存在。这也解释了为什么PDE的第三行和PTE的第二行可以直接忽略。</p>
<p>在上一篇文章中，有一个关于<a href="https://happy1wawayu.github.io/2022/03/18/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/10-10-12%E5%88%86%E9%A1%B5/#0%E5%9C%B0%E5%9D%80%E4%B9%9F%E8%83%BD%E5%AD%98%E5%80%BC%EF%BC%9F">0地址赋值</a>的实验。0地址之所以不能赋值是因为它的PTE的P位为0，在我们修改了PTE的P位，并给它挂上一个物理页后，0地址遍可以赋值了。</p>
<h2 id="R-x2F-W位"><a href="#R-x2F-W位" class="headerlink" title="R&#x2F;W位"></a>R&#x2F;W位</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-27-21-b034176b9f80e03df97fcfe7af55f9b4-RW-a6c90a.png"></p>
<ul>
<li>R&#x2F;W &#x3D; 0 只读</li>
<li>R&#x2F;W &#x3D; 1 可读可写</li>
</ul>
<p>R&#x2F;W很好理解，控制写的权限呗，这个位有何用呢？来看一个小实验。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	char* str = &quot;hello&quot;;</span><br><span class="line">	printf(&quot;%x&quot;, str);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	*str = &#x27;a&#x27;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	printf(&quot;%s&quot;, str);</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>来看这个代码，很明显，执行会是失败的，因为用char*定义的字符串，是会存储在常量区，而不是堆栈中了，又因为常量区的值是不允许修改的，因此</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*str = &#x27;a&#x27;;</span><br></pre></td></tr></table></figure>

<p>这条语句会执行失败并报错。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-27-39-b80e5b84ea59244bed1a5c6dcd3da680-RWCodeBefore-d877ed.png"></p>
<p>那为什么常量区的内容就不可修改呢？其实，说白了，就是常量区挂着的物理页的R&#x2F;W属性为0，因此只能读，不可写，既然知道了原因，我们只要修改了常量区所在物理页的属性，将R&#x2F;W位置1即可。</p>
<p>通过printf语句先打印出所在常量区的线性地址，接着拆分跟进PDE和PTE中（具体步骤省略）</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-27-53-c1fc242ea9ff6977acee3581c2f6b9c6-RWWin-8f4a00.png"></p>
<p>可以发现，PTE的R&#x2F;W位值为0，因此将其修改为1写入，随后运行程序发现，可以成功修改字符串首地址出的字符！</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-28-01-3f1b4b021d9189dbf19e9afe4e708be0-RWCodeAfter-109b89.png"></p>
<h2 id="P-x2F-S位"><a href="#P-x2F-S位" class="headerlink" title="P&#x2F;S位"></a>P&#x2F;S位</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-28-10-2dcd53816755424bb3a5290770a8206c-PS-1dfe78.png"></p>
<p>P&#x2F;S（PageSize）位，只对PDE有意义，位于PDE的第7位。</p>
<ul>
<li>PS &#x3D; 1 PDE直接指向物理页，无PTE，低22位为页内偏移。线性地址只能拆成两段（10-22）：页的大小为2的22次方，也就是4MB，俗称“大页”，大页比较少，一般出现在高2G中</li>
<li>PS &#x3D; 0 就是我们比较熟悉的10-10-12分页，页的大小为4KB</li>
</ul>
<h2 id="U-x2F-S位"><a href="#U-x2F-S位" class="headerlink" title="U&#x2F;S位"></a>U&#x2F;S位</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-28-19-80e31527d73ebb09af96d5449db8e044-US-e4961e.png"></p>
<p>U&#x2F;S（User&#x2F;System）位，位于PDE&#x2F;PTE的第2位。</p>
<ul>
<li>U&#x2F;S &#x3D; 0：特权用户</li>
<li>U&#x2F;S &#x3D; 1：普通用户</li>
</ul>
<p>三环程序是不能读写高2G内存的，原因在于高2G内存对应的物理页U&#x2F;S位被置0了，也就是说只有特权用户才能读写高2G的内存。所以，当普通用户想要读取高2G内存时，就可以把U&#x2F;S置1，这样就可以访问高2G内存了。</p>
<p>当然，理论如此，不过除了U&#x2F;S位外，影响高2G内存读写的还有PCD位和PWT位，所以第二种3环程序读写高2G实验（第一种是通过门提权），就要放到后面实现了，这里只要先记住，U&#x2F;S位是影响访问读写权限的。</p>
<h3 id="与R-x2F-W的区别"><a href="#与R-x2F-W的区别" class="headerlink" title="与R&#x2F;W的区别"></a>与R&#x2F;W的区别</h3><p>这里需要注意一下U&#x2F;S位与R&#x2F;W位的区别，U&#x2F;S位的读写控制是根据用户的级别，而R&#x2F;W位的控制是直接控制读写，不管你是不是特权用户。</p>
<h2 id="A位"><a href="#A位" class="headerlink" title="A位"></a>A位</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-28-29-37a2dc13f0cce521096c813fa5c743fc-A-bc4256.png"></p>
<p>A（Accessed）位于PDE&#x2F;PTE的第5位：表示该物理页是否被访问（读或者写）过，访问过置1，即使只访问一个字节也会导致PDE，PTE置1。</p>
<h2 id="D位"><a href="#D位" class="headerlink" title="D位"></a>D位</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-19-28-43-ed7f9fa4d2217f1ef70ac21c89e68b85-D-57108f.png"></p>
<p>D（Dirty），脏位，是否被写过。0表示没有被写过，1表示被写过</p>
<h2 id="PWT"><a href="#PWT" class="headerlink" title="PWT"></a>PWT</h2><p>Page Write Through</p>
<p>PWT &#x3D; 1 时 写CPU缓存的时候也要将数据写入内存中。</p>
<h2 id="PCD"><a href="#PCD" class="headerlink" title="PCD"></a>PCD</h2><p>Page Cache Disable</p>
<p>PCD &#x3D; 1时，禁止某个页写入缓存，直接写内存。</p>
<p>比如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上是关于PDE&#x2F;PTE部分属性的含义，还有一部分位没有涉及到，例如G位，PWT位，PCD位，这些需要讲到控制寄存器和TLB相关概念时再细讲。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>TLB&amp;控制寄存器</title>
    <url>/2022/03/23/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/TLB&amp;%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8/</url>
    <content><![CDATA[<h2 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h2><h3 id="设计原因"><a href="#设计原因" class="headerlink" title="设计原因"></a>设计原因</h3><ol>
<li>假设我们通过一个线性地址访问一个物理页，想要去读取物理页上某个字节。但是实际过程中，并非只读了1个字节，我们需要先读取PDE，再读取PTE，最后再读取存放1个字节的物理页，读取的内容远远超过1个字节了。</li>
<li>在2-9-9-12分页下，会多读24个字节，如果读取的内容跨页了（存在两个不同的物理页上），那多读的字节会更多</li>
</ol>
<p>为了提高效率，只能通过做记录来进行弥补。</p>
<p>因此CPU内部设计了一个表，用来做记录；由于位于CPU内部，速度和寄存器一样快，当然，表也不能做的过大。这个表叫做<strong>TLB（Translation Lookaside Buffer）</strong>，用于<strong>地址解析</strong></p>
<h3 id="TLB结构"><a href="#TLB结构" class="headerlink" title="TLB结构"></a>TLB结构</h3><table>
<thead>
<tr>
<th>LA（线性地址）</th>
<th>PA（物理地址）</th>
<th>ATTR（属性）</th>
<th>LRU（统计）</th>
</tr>
</thead>
<tbody><tr>
<td>xxxxxxxx</td>
<td>xxxxxxxx</td>
<td>xxxxxxxx</td>
<td>xxxxxxxx</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>ATTR（属性)：PAE分页，用PDPE&amp;PDE&amp;PTE。10-10-12分页则PDE&amp;PTE</li>
<li>不同CPU的TLB表大小不一样</li>
<li>只要Cr3改变了（<strong>说明进程切换了</strong>），先前的TLB则会失效，换一套新的TLB，一核一套TLB</li>
</ul>
<p>由于操作系统中的高2G映射基本不变，如果Cr3改了，直接刷新TLB，对于重建高2G以上的对应关系很浪费，所PDE和PTE中有个标志位G位，<strong>刷新TLB时将不会刷新PDE&#x2F;PTE的G位为1的页</strong>。若TLB满了，则CPU会根据统计信息将不常用的地址废弃，保留最近最常用的</p>
<p>注意：只有当PDE的PS位为1时（即当前物理页为大页），G位才有效。</p>
<h3 id="TLB种类"><a href="#TLB种类" class="headerlink" title="TLB种类"></a>TLB种类</h3><p>TLB在x86体系的CPU里的实际应用最早是从Intel的486CPU开始的，在x86的CPU里，一般都设有如下4组TLB：</p>
<ul>
<li>缓存一般页表（4K字节页面）的指令页表缓存（Instruction-TLB）</li>
<li>缓存一般页表（4K字节页面）的数据页表缓存（Data-TLB）</li>
<li>缓存大尺寸页表（2M&#x2F;4M字节页面）的指令页表缓存（Instruction-TLB）</li>
<li>缓存大尺寸页表（2M&#x2F;4M字节页面）的数据页表缓存（Instruction-TLB）</li>
</ul>
<h3 id="TLB验证"><a href="#TLB验证" class="headerlink" title="TLB验证"></a>TLB验证</h3><p>呵呵，这个破实验花了我一下午，我真是太菜了，一个原因是0地址挂物理页，踩了好几次坑，第二个是VC6很多强转不支持，耽误了很多时间。给0地址挂物理页的步骤就不赘述了，这里采用的10-10-12分页，只是采用了代码挂物理页的方式，具体可以参考<a href="https://happy1wawayu.github.io/2022/03/20/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/">基址小实验</a>这一篇，这里就讲讲验证的过程。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/addr1.png"></p>
<p>我们先给0地址挂上第一个地址（0x425000，这是我随便选的，选错了可能蓝屏）的物理页，然后取0地址的处的置，发现值为0。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/addr2.png"></p>
<p>这时，我们注释掉给0地址挂第一个地址（0x425000）的物理页的代码，并给0地址挂第二个地址（0x426000）的物理页。这时再取0地址处的值，发现值为0x43，可以发现，这两个线性地址所对应的物理页上的值是不同的。</p>
<p>这时我们把上面的注释拿掉，先给0地址挂第一个地址的物理页，然后再给0地址挂第二个地址的物理页，按照道理，这时我们取到的值应该是第二个地址对应物理页上的值，我们来查看结果：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/tlb.png"></p>
<p>神奇的事情发生了，我们取到的仍然是第一个地址对应物理页上的值，这其实就是TLB的作用。</p>
<p>这时，我们增加一条语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invlpg dword ptr ds:[0]</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-23-41-6a903226d1b14aca38dc0b1c31a11708-invlpg-348c97.png"></p>
<p>再次运行程序发现，仅仅多了这一条语句，读取0地址的值，就变成了第二个地址对应物理页上的值，Invlpg是让指定页TLB无效化的指令，因此再次访问时，原先的TLB已经被废弃，就需要重新去物理页读取，此时0地址对应的物理页已经是第二个地址的物理页了。当然，除了使用Invlpg指令，修改Cr3也可以做到让TLB无效化。</p>
<p>下面附上完整代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include </span><br><span class="line"></span><br><span class="line">DWORD phyAddr, phyAddr2, temp;</span><br><span class="line"></span><br><span class="line">__declspec(naked) Test() &#123;</span><br><span class="line">	_asm &#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">	&#125;	</span><br><span class="line">	phyAddr = (DWORD)(0xc0000000 + ((0x425000 &gt;&gt; 0xa) &amp; 0x3ffffc));</span><br><span class="line">	phyAddr2 = (DWORD)(0xc0000000 + ((0x426000 &gt;&gt; 0xa) &amp; 0x3ffffc));</span><br><span class="line"></span><br><span class="line">	_asm&#123;</span><br><span class="line">		mov eax, phyAddr</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov dword ptr ds:[0xc0000000], eax</span><br><span class="line">		mov eax, dword ptr ds:[0]</span><br><span class="line">		mov temp, eax</span><br><span class="line"></span><br><span class="line">//		invlpg dword ptr ds:[0]		无效化指定页的TLB</span><br><span class="line">//		mov eax, cr3			 	切换Cr3来清空TLB</span><br><span class="line">//		mov cr3, eax</span><br><span class="line">	</span><br><span class="line">		mov eax, phyAddr2</span><br><span class="line">		mov eax, [eax]</span><br><span class="line">		mov dword ptr ds:[0xc0000000], eax</span><br><span class="line">		mov eax, dword ptr ds:[0]</span><br><span class="line">		mov temp, eax</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	_asm&#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	char buffer[] = &#123;0, 0, 0, 0, 0x4B, 0&#125;;</span><br><span class="line">	_asm call fword ptr buffer</span><br><span class="line">	</span><br><span class="line">	printf(&quot;temp: %x&quot;, temp);</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h2><p>说完了TLB，来说说控制寄存器。控制寄存器的作用主要是用于控制和确定CPU的操作模式。主要包括Cr0，Cr1，Cr2，Cr3，Cr4，其中Cr1保留。</p>
<h3 id="Cr0寄存器"><a href="#Cr0寄存器" class="headerlink" title="Cr0寄存器"></a>Cr0寄存器</h3><p>Cr0寄存器，主要包括一些控制操作系统模式以及处理器状态的控制标志位。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-24-40-04a60f21d98591bb61384c167974299a-cr0-5c3dad.png"></p>
<p>这里介绍几个主要的标志位，其余位的描述可以参考Intel白皮书第三卷系统架构综述那章。</p>
<ol>
<li>PE：Cr0下标为0的位是启用保护（Protection Enable）标志。PE&#x3D;1保护模式，PE&#x3D;0实地址模式，<strong>这个标志仅开启段级保护，而并没有启用分页机制</strong>。若要启用分页机制，那么PE和PG标志都要置位。</li>
<li>PG：当设置该位时即开启了分页机制。在<strong>开启这个标志之前必须已经或者同时开启PE标志</strong>。<ul>
<li>PG&#x3D;0且PE&#x3D;0：处理器工作在实地址模式下</li>
<li>PG&#x3D;0且PE&#x3D;1：处理器工作在没有开启分页机制的保护模式下（不存在这样的操作系统）</li>
<li>PG&#x3D;1且PE&#x3D;0：在PE没有开启的情况下 无法开启PG</li>
<li>PG&#x3D;1且PE&#x3D;1：处理器工作在开启了分页机制的保护模式下</li>
</ul>
</li>
<li>WP：对于Intel 80486或以上的CPU，CR0的位16是写保护（Write Proctect）标志，当设置该标志时，处理器会禁止超级用户程序（例如特权级0的程序）向用户级只读页面执行写操作。<ul>
<li>对于Ring0的特权级程序，如果WP&#x3D;0，可以<strong>读写</strong>任意用户级物理页，只要线性地址有效</li>
<li>对于Ring0的特权级程序，如果 WP&#x3D;1 可以<strong>读取</strong>任意用户级物理页，但对于只读的物理页，则不能写</li>
</ul>
</li>
</ol>
<h3 id="Cr2寄存器"><a href="#Cr2寄存器" class="headerlink" title="Cr2寄存器"></a>Cr2寄存器</h3><p>Cr2寄存器，保存导致缺页异常的线性地址。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-25-00-4328630b17f5ab432f35653467b157b5-cr2-4595af.png"></p>
<p>之前在中断与异常中，简要概括了<a href="https://happy1wawayu.github.io/2022/03/24/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/#%E7%BC%BA%E9%A1%B5%E5%BC%82%E5%B8%B8%EF%BC%88%E6%97%A0%E6%97%B6%E6%97%A0%E5%88%BB%E4%B8%8D%E5%9C%A8%E5%8F%91%E7%94%9F%EF%BC%89">缺页异常</a>，当CPU访问某个无效页面，会产生缺页异常，此时，CPU会将引起异常的线性地址存放在Cr2中，以便操作系统处理完缺页异常后，返回到原本执行的位置继续执行。</p>
<h3 id="Cr3寄存器"><a href="#Cr3寄存器" class="headerlink" title="Cr3寄存器"></a>Cr3寄存器</h3><p>Cr3我们太熟悉了，在10-10-12分页是页目录表基址，在PAE分页下，则是页目录指针表基址</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-25-09-e29215802d8a79b51dcaff1041cc4635-cr3-d1cb62.png"></p>
<p>这里有两个属性，PWT和PCD之前在页的部分一直没有讲，在介绍之前，先来了解一个概念，叫做CPU缓存</p>
<h4 id="CPU缓存"><a href="#CPU缓存" class="headerlink" title="CPU缓存"></a>CPU缓存</h4><ol>
<li>CPU缓存是位于CPU与物理内存之间的临时存储器，它的容量比内存小的多，但是交换速度远快于内存。</li>
<li>CPU缓存可以做的很大，从几K，几十K，几百K，甚至上M。</li>
<li>CPU缓存与TLB的区别：<ul>
<li>TLB：线性地址 &lt;—–&gt; 物理地址</li>
<li>CPU缓存： 物理地址 &lt;—–&gt; 内存</li>
</ul>
</li>
</ol>
<p>有了CPU缓存和TLB的概念后，就可以来讲讲PWT和PCD这俩属性了。</p>
<h4 id="PWT-Page-Write-Through"><a href="#PWT-Page-Write-Through" class="headerlink" title="PWT(Page Write Through)"></a>PWT(Page Write Through)</h4><ul>
<li>PWT &#x3D; 1时，CPU向cache写入数据时，同时向memory也写一份，使cache和memory的数据保持一致。优点是简单，缺点是每次都要访问memory，速度比较慢，即Write Through。</li>
<li>PWT &#x3D; 0时，CPU向cache写入数据时，不将数据写入内存中，分为两种情况：<ol>
<li>Post Write：CPU更新cache数据时，把更新的数据写入到一个更新缓冲器，在合适的时候才对memory进行更新。这样可以提高cache访问速度，但是，在数据连续被更新两次以上的时候，缓冲区将不够使用，被迫同时更新memory。</li>
<li>Write Back：CPU更新cache时，只是把更新的cache区标记一下，并不同步更新memory。只是在cache区要被新进入的数据取代时，才更新memory。这样做的原因是考虑到很多时候cache存入的是中间结果，没有必要同步更新memory。优点是CPU执行的效率提高，缺点是实现起来技术比较复杂。</li>
</ol>
</li>
</ul>
<h4 id="PCD-Page-Cache-Disable"><a href="#PCD-Page-Cache-Disable" class="headerlink" title="PCD(Page Cache Disable)"></a>PCD(Page Cache Disable)</h4><ul>
<li>PCD &#x3D; 1时，禁止某个页写入缓存，直接写入内存。例如，做页表用的页，已经存储在TLB中了，可能不需要再缓存了。</li>
<li>PCD &#x3D; 0时，不限制页写入缓存，可以参考上面PWT的情况。</li>
</ul>
<h3 id="Cr4寄存器"><a href="#Cr4寄存器" class="headerlink" title="Cr4寄存器"></a>Cr4寄存器</h3><p>Cr4寄存器，保存了一组启用多种架构扩展的标志位</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-25-25-012ebd6b86afb5af3d979ae357997d10-cr4-f47718.png"></p>
<p>这里简单概括一下PAE位和PSE位：</p>
<ul>
<li>PAE：置1时，是PAE分页；置0时，是10-10-12分页。之前在boot.ini中设置execute&#x2F;noexecute的作用就是修改PAE位</li>
<li>PSE：控制PDE中PS位的开关，当PSE置1时，PS位才有效。具体如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-25-54-e0c3f779eaddaabf3d9e06f71fc9159a-PSE-794160.png"></p>
<h3 id="控制寄存器小结"><a href="#控制寄存器小结" class="headerlink" title="控制寄存器小结"></a>控制寄存器小结</h3><p>除了上述介绍的，还有一个Cr8寄存器，仅仅在64位下才存在，这里就不作介绍了，其余寄存器总览如下：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-13-26-29-74d02564f7c853aec3462d0d4959b266-cr-bdda4d.png"></p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中断与异常</title>
    <url>/2022/03/24/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E6%96%AD%E4%B8%8E%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><h3 id="什么是中断"><a href="#什么是中断" class="headerlink" title="什么是中断"></a>什么是中断</h3><ol>
<li>中断通常是由CPU外部的输入输出设别（<strong>硬件</strong>）所触发的，供外部设备通知CPU“有事情需要处理”，因此又叫做中断请求（<strong>IRQ-Interrupt Request</strong>）</li>
<li>中断请求的目的是希望CPU暂时停止执行当前<strong>正在执行</strong>的程序，转去执行中断请求所对应的中断处理例程（<strong>中断处理程序在哪由IDT表决定</strong>）</li>
<li>80x86有两条中断请求线：<ul>
<li>不可屏蔽中断线，称为<strong>NMI（NonMaskable Interrupt）</strong></li>
<li>可屏蔽中断线，称为<strong>INTR（Interrupt Require）</strong></li>
</ul>
</li>
</ol>
<h3 id="不可屏蔽中断"><a href="#不可屏蔽中断" class="headerlink" title="不可屏蔽中断"></a>不可屏蔽中断</h3><table>
<thead>
<tr>
<th>（IDT表）中断号</th>
<th>NMI</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x2</td>
<td>不可屏蔽中断</td>
<td>80x86中固定为0x2</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>当不可屏蔽中断产生时，CPU在执行完当前指令后会立即进入2号中断，执行相应中断处理程序</li>
<li>不可屏蔽中断不受EFLAG寄存器中IF位的影响，一旦发生，CPU必须处理</li>
</ul>
<h3 id="可屏蔽中断"><a href="#可屏蔽中断" class="headerlink" title="可屏蔽中断"></a>可屏蔽中断</h3><p>在硬件级，可屏蔽中断是由一块专门的芯片来管理的，通常称为<strong>中断控制器</strong>。它负责分配中断资源和管理各个中断源发出的中断请求。为了便于标识各个中断请求，中断控制器通常用<strong>IRQ（Interrupt Request）</strong>后面加上数字来表示不同的中断。</p>
<p>例如：在Windows中，时钟中断的IRQ编号为0，也就是：IRQ0</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-14-09-44-12c11df6822da09bd28c093a1bcf7e9d-time-785f23.png"></p>
<table>
<thead>
<tr>
<th>（IDT表）中断号</th>
<th>IRQ</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x30</td>
<td>IRQ0</td>
<td>时钟中断</td>
</tr>
<tr>
<td>0x31~0x3F</td>
<td>IRQ1~IRQ15</td>
<td>其它硬件设备的中断</td>
</tr>
</tbody></table>
<p>说明：</p>
<ul>
<li>如果自己的程序执行时不希望CPU去处理这些中断，可以用<strong>CLI</strong>指令清空EFLAG寄存器中的IF位。与CLI指令相反，<strong>STI</strong>指令可以用来设置EFLAG寄存器中的IF位</li>
<li>硬件中断与IDT表中的对应关系并且固定不变的，参见<strong>APIC</strong>（高级可编程中断控制器）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-14-09-52-aab31730dd09f458c47fcdca4df3fd67-APIC-1df766.png"></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>聊完了中断，来看看异常。异常通常是CPU在执行指令时检测到的某些错误，比如除0、访问无效页面等。</p>
<h3 id="与中断的区别"><a href="#与中断的区别" class="headerlink" title="与中断的区别"></a>与中断的区别</h3><ul>
<li>中断来自于外部设备，是中断源（例如键盘）发起的，CPU是被动的。</li>
<li>异常来自于CPU本身，是CPU主动产生的。</li>
<li>INT N虽然被称为“软件中断”，但其本质是<strong>异常</strong>。因此<strong>不受EFLAG的IF位影响</strong>。</li>
</ul>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>无论是由硬件设备触发的<strong>中断请求</strong>还是由CPU产生的<strong>异常</strong>，<strong>处理程序都在IDT表</strong>。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-14-10-09-0f02282d6ae420ce56eb80f212bb696b-idt-87b515.png"></p>
<p>上图为IDT表中常见的中断向量号的相关描述，具体细节可以参考Intel白皮书第三卷（Exception And Interrupt Reference）这章</p>
<h3 id="缺页异常（无时无刻不在发生）"><a href="#缺页异常（无时无刻不在发生）" class="headerlink" title="缺页异常（无时无刻不在发生）"></a>缺页异常（无时无刻不在发生）</h3><p>缺页异常产生：</p>
<ul>
<li>当PDE&#x2F;PTE的P&#x3D;0时</li>
<li>当PDE&#x2F;PTE的属性为只读，但程序试图写入时</li>
</ul>
<p>一旦发生缺页异常，CPU会执行IDT表中的0xE号中断处理程序，由操作系统接管。</p>
<p>这里简单概括上述两种发生缺页异常的情况：</p>
<ol>
<li>在操作系统中，物理页往往是紧缺的，若当前PTE指向的物理页的内容一段时间没有被访问，则会将这个物理页上的内容存到一个文件里，同时将这个物理页挂给有需要的PTE用，并将原PTE的P位置0。当程序再次访问这段内容时，发现P位为0，则会触发缺页异常，但是此时PTE下标为10,11的位置均为0，其余位置都是有值的，这种情况说明当前PTE指向的内容存到了文件中，并根据下标1~4指定的偏移，在文件中找到内容。这时再重新给这些内容挂上新的物理页，将P位改为1，这时访问便可正常执行。当然，缺页异常对于用户来说是透明的，用户只会觉得自己正常访问了某个内容，但实际上进行了很多操作，通过缺页异常，操作系统可以节省大量物理页。 <img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-24-14-10-28-30cb6365ba122cd996320de91d9fb256-defaultPage-a6ea39.png">])</li>
<li>当PDE&#x2F;PTE属性为只读时，CPU不会进行处理，而是跳到E号中断交给操作系统来处理，操作系统发现程序正在尝试写一个只读的物理页，会返回一个C0000005错误。</li>
</ol>
<h3 id="异常小节"><a href="#异常小节" class="headerlink" title="异常小节"></a>异常小节</h3><p>当异常发生时，CPU会判断异常的种类，根据中断向量号，跳转到相应的异常处理程序，接着由操作系统接管并处理。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇简要介绍了中断与异常，在后续讲到中断章节时，会更加详细的分析过程原理。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>任务段</title>
    <url>/2022/03/16/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E4%BB%BB%E5%8A%A1%E6%AE%B5/</url>
    <content><![CDATA[<blockquote>
<p>在调用门、中断门与陷阱门中，一旦发生权限切换，那么就必有堆栈的切换。而且，由于CS的CPL发生改变，也导致了SS也必须要切换。</p>
<p>那么问题来了，我们知道EIP和CS的值都可以通过门描述符获得，那么ESP和SS是哪来的？</p>
<p>这就是引出了今天的内容：<strong>TSS</strong>（Task-state segment），任务状态段。</p>
</blockquote>
<h2 id="TSS设计初衷"><a href="#TSS设计初衷" class="headerlink" title="TSS设计初衷"></a>TSS设计初衷</h2><p>想要学习一类知识，首先要了解它被设计出来的目的，这样就能找到方向，更好的了解它。CPU在运行时会频繁的切换任务，每次切换任务时，还没执行完的任务怎么办？总不能下次重新执行吧，于是需要保存上一个任务的上下文环境，于是，TSS诞生了，<strong>TSS是一块大小为104(0x68)个字节的内存</strong>，没错，<strong>TSS</strong>不是什么寄存器，<strong>就是一段内存，或者说是一个段</strong>，这段内存可以保存32-Bit下所有通用寄存器以及段寄存器的值，这样CPU就可以切换到新任务时，仍然保留上一个任务的环境，方便新任务执行完后，能够完好的回到先前的任务继续执行。</p>
<p>注意，TSS是一个段，有段就有段寄存器和段描述符哟！比如我们熟悉的CS，CS就是<strong>段寄存器</strong>，它描述的是<strong>代码段</strong>，同时，它会通过段选择子从GDT表的<strong>代码段描述符</strong>中载入段的相关信息，通常情况下，代码段的范围是0~FFFFFFFF（大小是4GB）；这样一对比，就可以理解了，TSS也是如此，因为TSS也是一个段（大小是104字节），所以应该存在一个描述TSS的段寄存器从一个段描述符里加载TSS相关信息。这就是今天会依次介绍的TR寄存器和TSS段描述符。</p>
<p>这里补充一点知识，尽管Intel设计TSS的初衷的为了方便任务切换（<strong>CPU层面叫做任务切换，操作系统层面叫做线程切换</strong>），但是Windows认为这个TSS设计的不好，因此并没有采用这个结构进行线程切换，并且Linux也没有采用TSS进行线程切换，这俩操作系统用的都是堆栈进行线程切换的。那么Windows用到了这个结构没有，当然是用到了，但仅仅用到了ESP0和SS0这两个值。</p>
<h2 id="TSS结构"><a href="#TSS结构" class="headerlink" title="TSS结构"></a>TSS结构</h2><p>先来看看TSS的结构</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/tss.png" alt="img"></p>
<p>大部分都应该比较熟悉，这里介绍几个较为陌生的字段：</p>
<ul>
<li>Previous Task Link：这里保存的是<strong>上一个TSS的段选择子</strong>，比如任务发生了切换，新任务执行完后，如何才能找到先前未能执行完的任务呢？就得依靠这个值了（前面不是说了Windows不用TSS进行线程切换嘛，是呀，但是这里讲解的这个字段的作用，设计初衷就是为了任务切换）</li>
<li>ESP0&#x2F;SS0：当发生提权时，0环的ESP和SS的值就是从这里取的</li>
<li>CR3：有人会问，我哪知道取哪个TSS的ESP0和SS0呢？就是这个值的作用了，这个值帮我们<strong>确定当前位于哪个线程</strong>，之后在页的篇章中会学到CR3的相关内容。</li>
<li>LDT：这个值通常都是0，Windows没有用到LDT表，因为<strong>LDT表只对当前的线程有用</strong></li>
<li>I&#x2F;O Map：这个位置涉及到硬件IO了，值一般是固定的</li>
</ul>
<h2 id="TSS段描述符"><a href="#TSS段描述符" class="headerlink" title="TSS段描述符"></a>TSS段描述符</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/tssDesc.png" alt="img"></p>
<p>TSS段描述符只能存在GDT表中，不能存到LDT或者IDT中，所以它的结构和之前介绍的段描述符是类似的，区别在于个别位的不同</p>
<ul>
<li>G位：在代码段&#x2F;数据段描述符中，这个位置通常位1，因为这两个段的范围通常是4GB，而TSS的大小是104字节，单位是字节，因此这个值为0</li>
<li>Type域：这个值为1011或1001，其中B位是Busy位，置1时说明该TSS是否被载入或者嵌套，载入说明CPU正在执行该任务；嵌套则表明该任务处理了一半，切换到了另一个任务中去，但该任务并未执行完。</li>
<li>Base&#x2F;Limit：Base确定TSS段的起始位置，Limit确定TSS段的大小，Base~Base+Limit就是TSS段的范围。</li>
</ul>
<h2 id="TR寄存器"><a href="#TR寄存器" class="headerlink" title="TR寄存器"></a>TR寄存器</h2><p>CPU共有8个段寄存器，TR就是其中之一。</p>
<p>TR寄存器的工作原理和其它段寄存器一样，通过段选择子加载GDT表的TSS段描述符中的信息，<strong>方便CPU找到TSS的位置</strong>，具体工作原理如下：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/tr.png"></p>
<p>这里介绍两个操作TR段寄存器的指令LTR和STR：</p>
<ul>
<li>LTR：这是一个特权指令，只有0环的程序才能调用；作用是将段选择子写入TR寄存器</li>
<li>STR：STR不是特权指令，这个指令3环程序也可以调用，所用是读取TR寄存器的值</li>
</ul>
<p>需要注意的一点，修改TR寄存器的值，只是会载入新的TSS段描述符信息，并不会对修改前的TSS段造成影响。</p>
<h2 id="实现任务切换"><a href="#实现任务切换" class="headerlink" title="实现任务切换"></a>实现任务切换</h2><p>虽然说了Windows并没有将TSS用来进行线程切换，但是我们仍然可以手动实现任务的切换。</p>
<p>直接修改TR寄存器是不能做到任务切换的，但是可以通过JMP FAR或者CALL FAR来加载TSS段描述符来实现。下面分别使用两种方法来实现（两种实现方法细节有很多差别）</p>
<p>一般情况下，<strong>任务切换发生在下列四种情况</strong>之一：</p>
<ul>
<li>当前程序，任务或者进程执行JMP&#x2F;CALL语句，且参数是位于GDT表中的TSS段描述符</li>
<li>当前程序，任务或者进程执行JMP&#x2F;CALL语句，且参数是位于GDT表或者当前LDT表中的任务门描述符</li>
<li>一个中断或者异常触发了在IDT表中的任务门描述符</li>
<li>当前任务执行IRET指令，且EFLAGS寄存器的NT位为1时</li>
</ul>
<h3 id="CALL-FAR实现"><a href="#CALL-FAR实现" class="headerlink" title="CALL FAR实现"></a>CALL FAR实现</h3><p>本次CALL FAR实现采用第一种任务切换的情况。</p>
<p>设计一个TSS，存储任务切换时必要的信息，其中包括ESP0，SS0，CR3，EIP，ESP，段寄存器，位图控制。</p>
<ul>
<li>ESP0：也就是任务切换后的堆栈，可以自己创一个空数组，然后写入数组的首地址，就可以作为堆栈使用。</li>
<li>段寄存器及SS0：这些值，在0环通常都一样，可以进入Windbg参考其它TSS的值，这里使用的是SS&#x2F;SS0 &#x3D; 0x10，ES&#x2F;DS &#x3D; 0x23，CS &#x3D; 0x8，FS &#x3D; 0x30，GS &#x3D; 0x0</li>
<li>EIP：这就是要跳转后执行的地方，可以写一个裸函数来验证是否切换成功，直接取裸函数地址即可，我这里的值为0x401020（每个人机器可能不一样）</li>
<li>CR3：这个值，需要在执行前，中断到Windbg寄存器中，通过!process 0 0指令获取。</li>
<li>位图控制：这是一个默认值为0x20AC0000</li>
</ul>
<p>构造完的TSS如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DWORD tss[0x68] = &#123;</span><br><span class="line">		0x00000000,	//Previous Task Link</span><br><span class="line">		(DWORD)stack,	//ESP0</span><br><span class="line">		0x00000010,	//SS0</span><br><span class="line">		0x00000000, //ESP1</span><br><span class="line">		0x00000000, //SS1</span><br><span class="line">		0x00000000, //ESP2</span><br><span class="line">		0x00000000, //SS2</span><br><span class="line">		(DWORD)Cr3,	//Cr3</span><br><span class="line">		0x00401020,	//EIP</span><br><span class="line">		0x00000000,	//EFLAGS</span><br><span class="line">		0x00000000,	//EAX</span><br><span class="line">		0x00000000,	//ECX</span><br><span class="line">		0x00000000,	//EDX</span><br><span class="line">		0x00000000,	//EBX</span><br><span class="line">		(DWORD)stack,	//ESP</span><br><span class="line">		0x00000000,	//EBP</span><br><span class="line">		0x00000000,	//ESI</span><br><span class="line">		0x00000000,	//EDI</span><br><span class="line">		0x00000023,	//ES</span><br><span class="line">		0x00000008, //CS</span><br><span class="line">		0x00000010,	//SS</span><br><span class="line">		0x00000023,	//DS</span><br><span class="line">		0x00000030,	//FS</span><br><span class="line">		0x00000000,	//GS</span><br><span class="line">		0x00000000,	//LDT</span><br><span class="line">		0x20ac0000	//IO_MAP</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>

<p>然后我们需要根据这个TSS的地址，来构造我们的TSS段描述符</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/tssAddr.png"></p>
<p>地址为0x12fd70</p>
<p>因此TSS段描述符为：0000e912&#96;fd700068，e-&gt;DPL&#x3D;3：是为了3环的程序可以访问这个段描述符，0x68就是104字节，9说明未被载入。然后让我们填入段描述符</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/segDesc.png"></p>
<p>接着运行程序，需要采集Cr3的值，先中断到Windbg，再通过!process 0 0指令获取，取最后的一个值</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/cr3.png"></p>
<p>在程序中填入cr3的值后回车，发现可以成功取到任务切换后ESP，CS，SS，并且均为我们设定的值，实验成功。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/callFar.png"></p>
<p>完整代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> saveEax, newESP;</span><br><span class="line"><span class="type">short</span> newCS, newSS;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="type">void</span> <span class="title">Get_Value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		mov saveEax, eax</span><br><span class="line">		mov newESP, esp</span><br><span class="line">		mov ax, cs</span><br><span class="line">		mov newCS, ax</span><br><span class="line">		mov ax, ss</span><br><span class="line">		mov newSS, ax</span><br><span class="line">		mov eax, saveEax</span><br><span class="line">		iret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> stack[<span class="number">100</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">char</span> buffer[<span class="number">6</span>] = &#123;<span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x4B</span>, <span class="number">0x0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> Cr3 = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Input: &quot;</span>);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%x&quot;</span>, &amp;Cr3);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line">	DWORD tss[<span class="number">0x68</span>] = &#123;</span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//Previous Task Link</span></span><br><span class="line">		(DWORD)stack,	<span class="comment">//ESP0</span></span><br><span class="line">		<span class="number">0x00000010</span>,	<span class="comment">//SS0</span></span><br><span class="line">		<span class="number">0x00000000</span>, <span class="comment">//ESP1</span></span><br><span class="line">		<span class="number">0x00000000</span>, <span class="comment">//SS1</span></span><br><span class="line">		<span class="number">0x00000000</span>, <span class="comment">//ESP2</span></span><br><span class="line">		<span class="number">0x00000000</span>, <span class="comment">//SS2</span></span><br><span class="line">		(DWORD)Cr3,	<span class="comment">//Cr3</span></span><br><span class="line">		<span class="number">0x00401020</span>,	<span class="comment">//EIP</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//EFLAGS</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//EAX</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//ECX</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//EDX</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//EBX</span></span><br><span class="line">		(DWORD)stack,	<span class="comment">//ESP</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//EBP</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//ESI</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//EDI</span></span><br><span class="line">		<span class="number">0x00000023</span>,	<span class="comment">//ES</span></span><br><span class="line">		<span class="number">0x00000008</span>, <span class="comment">//CS</span></span><br><span class="line">		<span class="number">0x00000010</span>,	<span class="comment">//SS</span></span><br><span class="line">		<span class="number">0x00000023</span>,	<span class="comment">//DS</span></span><br><span class="line">		<span class="number">0x00000030</span>,	<span class="comment">//FS</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//GS</span></span><br><span class="line">		<span class="number">0x00000000</span>,	<span class="comment">//LDT</span></span><br><span class="line">		<span class="number">0x20ac0000</span>	<span class="comment">//IO_MAP</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	_asm &#123;</span><br><span class="line">		call fword ptr buffer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ESP: %x, cs: %x, ss: %x&quot;</span>, newESP, newCS, newSS);</span><br><span class="line">	<span class="built_in">getchar</span>();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JMP-FAR实现"><a href="#JMP-FAR实现" class="headerlink" title="JMP FAR实现"></a>JMP FAR实现</h3><p>还有另一种方法，是通过JMP FAR来实现，而且JMP FAR实现会更加困难一些。这里简要概括一下，当使用CALL FAR时，CPU会自动帮你用当前任务的段选择子填写你TSS的Previous Task Link字段，同时给你的Eflags的NT位置1，这个NT位有什么用呢，就是关系到iret这个指令的意义，当Elfags的NT为1时，iret表示根据Previous Task Link的值，从当前任务返回到前一个任务中去，当NT为0时，这是一个中断返回指令。而当你使用JMP FAR实现时，你需要手动给Pervious Task Link字段赋上前一个任务的段选择子，此外你需要手动给Eflags的NT位置1，当然这可以通过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pushfd</span><br><span class="line">mov eax, [esp]</span><br><span class="line">or eax, 0x4000</span><br><span class="line">mov [esp], eax</span><br><span class="line">popfd</span><br></pre></td></tr></table></figure>

<p>来实现，此外，还需要确保前一个TSS段的段描述符Busy位的值为1，这样才能确保该任务处在嵌入的状态。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>任务门</title>
    <url>/2022/03/17/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E4%BB%BB%E5%8A%A1%E9%97%A8/</url>
    <content><![CDATA[<h2 id="为何使用任务门"><a href="#为何使用任务门" class="headerlink" title="为何使用任务门"></a>为何使用任务门</h2><p>之前任务段中提到，进行任何切换时可以还可以使用任务门。那么既然存在TSS段描述符了，为何还需要任务门呢？</p>
<p>简要概括，任务门有如下优势：</p>
<ul>
<li>任务门可以放在GDT表中，也可以放在IDT表中，还能放在当前线程的LDT表中，而TSS段描述符只能在GDT表中</li>
<li>任务门可以让低权限的线程进行任何切换，任务门的结构中也有DPL属性，当通过任务门去访问TSS描述符时，一旦通过任务门，TSS段描述符就不再进行检查了，即使你是个CPL&#x3D;3的程序，而TSS段描述符的DPL&#x3D;0，只要任务门DPL&#x3D;3，就可以通过任务门完成任务切换，稍后会做这个实验。</li>
<li>由于任务门可以位于IDT表中，所以当遇到中断或者异常时，可以切换到独立的任务去处理异常</li>
</ul>
<p>下面为不同表中，任务门进行任务切换的过程：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/table.png"></p>
<h2 id="任务门描述符"><a href="#任务门描述符" class="headerlink" title="任务门描述符"></a>任务门描述符</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/taskGate.png"></p>
<p>任务门描述符的结构非常简单，真正用到的只有24位，属性位里：DPL一般设置为3，方便应用程序访问，Type则是固定的0101，TSS段选择子，顾名思义，就是一个段选择子，指向位于GDT表中TSS段描述符的位置。其余位均为保留位，置0即可。</p>
<h2 id="任务门实现任务切换"><a href="#任务门实现任务切换" class="headerlink" title="任务门实现任务切换"></a>任务门实现任务切换</h2><p>这一步十分简单，仅仅比使用TSS多了一个步骤而已，这里也不细讲了，直接上步骤。</p>
<p>首先，编译源文件，下断点，确定TSS的地址，根据地址构造TSS段描述符：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/structDesc.png"></p>
<p>第二步，根据GDT表中构造好的TSS段描述符位置，在IDT表中构造任务门：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/structSelect.png"></p>
<p>第三步，在Windbg中使用!process 0 0指令确定CR3的值，并填入自己的TSS中：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/dirbase.png"></p>
<p>执行程序，获取到自己构造的TSS表数据，任务切换成功：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/result.png"></p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>基址小实验（10-10-12）</title>
    <url>/2022/03/20/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E5%9F%BA%E5%9D%80%E5%B0%8F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<p>在学习完页目录表基址，页表基址后，我们知道通过<code>0xC0300000</code>和<code>0xC0000000</code>这两个地址，可以访问相应的PDE和PTE，今天就来实践一下。</p>
<p>之前在介绍PDE&#x2F;PTE属性R&#x2F;W位时有过一个实验，是<a href="https://happy1wawayu.github.io/2022/03/19/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/PDE_PTE%E5%B1%9E%E6%80%A7/#R-W%E4%BD%8D">对位于常量区的内容进行修改</a>，当时通过Windbg修改了所在PDE&#x2F;PTE的R&#x2F;W位。这次实验，我们利用页目录表&#x2F;页表基址来进行修改。</p>
<h2 id="测试原始代码"><a href="#测试原始代码" class="headerlink" title="测试原始代码"></a>测试原始代码</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-14-14-06-946691fd700d1b1c1e8d4d29276e8289-before-414890.png"></p>
<p>首先测试原始代码，发现直接修改常量区的字符串，是会失败的</p>
<h2 id="提权进入0环"><a href="#提权进入0环" class="headerlink" title="提权进入0环"></a>提权进入0环</h2><p>提权这里还是会用到Windbg，根据调用函数的地址，填入段选择子，并通过调用门进行提权（就当复习调用门知识了）</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-14-13-54-05021cd34209ff0f52323592744b5199-addr-5603f1.png"> </p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-14-14-35-144d87388db62a38ec244f39dcc05dbc-windbg-c764d6.png"></p>
<h2 id="修改R-x2F-W位"><a href="#修改R-x2F-W位" class="headerlink" title="修改R&#x2F;W位"></a>修改R&#x2F;W位</h2><p>提权进入0环后（为啥要提权呢？因为C0300000&#x2F;C0000000都属于高2G的线性地址，3环没法直接访问），就到了我们最关键的步骤了，修改R&#x2F;W位。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temp = *(int*)0xC0300004;</span><br><span class="line">temp = temp|0x2;</span><br><span class="line">*(int*)0xC0300004 = temp;</span><br><span class="line">temp = *(int*)0xC000108C;</span><br><span class="line">temp = temp|0x2;</span><br><span class="line">*(int*)0xC000108C = temp;</span><br></pre></td></tr></table></figure>

<p>在这之前声明了一个中间变量temp（int类型）。</p>
<p>具体步骤：</p>
<ol>
<li>打印出字符串所在常量区的地址0x423fb0，进行拆分：10-10-12 -&gt; 0x1-0x23-0xfb0</li>
<li>PDI &#x3D; 0x1，带入公式：PDE &#x3D; C0300000 + 0x1 x 4</li>
<li>PTI &#x3D; 0x23，带入公式：PTE &#x3D; C0000000 + 0x1 x 1000 + 0x23 x 4</li>
<li>分别取PDE和PTE处的值，并<strong>和0x2进行或运算（将R&#x2F;W位置1）</strong></li>
</ol>
<p>这样就完成了对R&#x2F;W位的修改，在接下来再次对常量区的值进行修改操作时，便可以成功。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-46-50-05a67d4539354f9f4778a64126020e49-after-7736fd.png"></p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line"></span><br><span class="line">int temp;</span><br><span class="line"></span><br><span class="line">__declspec(naked) void ModifyRW() &#123;</span><br><span class="line">	__asm &#123;</span><br><span class="line">		pushad</span><br><span class="line">		pushfd</span><br><span class="line">	&#125;</span><br><span class="line">	temp = *(int*)0xC0300004;</span><br><span class="line">	temp = temp|0x2;</span><br><span class="line">	*(int*)0xC0300004 = temp;</span><br><span class="line">	temp = *(int*)0xC000108C;</span><br><span class="line">	temp = temp|0x2;</span><br><span class="line">	*(int*)0xC000108C = temp;</span><br><span class="line">	</span><br><span class="line">	__asm &#123;</span><br><span class="line">		popfd</span><br><span class="line">		popad</span><br><span class="line">		retf</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	char* str = &quot;hello&quot;; </span><br><span class="line">	char buffer[6] = &#123;0, 0, 0, 0, 0x4B, 0&#125;;</span><br><span class="line">	printf(&quot;addr: %x, str: %s&quot;, str, str);</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	_asm &#123;</span><br><span class="line">		call fword ptr buffer</span><br><span class="line">	&#125;</span><br><span class="line">	*str = &#x27;a&#x27;;</span><br><span class="line">	printf(&quot;str: %s&quot;, str);</span><br><span class="line">	getchar();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向分析MmIsAddressValid（10-10-12）</title>
    <url>/2022/03/21/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90MmIsAddressValid/</url>
    <content><![CDATA[<p>在对页表基址，页目录表基址熟练掌握后，今天来看逆向分析一个函数：MmIsAddressValid。这是一个系统函数，可以在ntoskrnl.exe的导出函数中找到它，也可以在Windbg中输入指令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; u MmIsAddressValid</span><br></pre></td></tr></table></figure>

<p>查看。</p>
<p>为什么要分析这个函数呢？因为即使是系统函数，也是无法直接使用物理页的，想要去访问PDE和PTE也就一定要通过基址来访问，而今天要分析的MmIsAddressValid函数，就利用了这么一个原理，相比前一篇的基址小实验，这里对于线性地址拆分的过程更为巧妙，让我们一起来看看吧！</p>
<h2 id="获取PDE属性"><a href="#获取PDE属性" class="headerlink" title="获取PDE属性"></a>获取PDE属性</h2><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-23-12-04-35-dad27cbe16aabf5c4d005018b697acc7-original-ac218c.png"></p>
<p>首先观察函数主体部分，发现代码并不长，但是有很多跳转，具体跳转内容就不作分析了，主要是分析函数主体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">804e4661 8bff            mov     edi,edi                ; hotpatch</span><br><span class="line">804e4663 55              push    ebp</span><br><span class="line">804e4664 8bec            mov     ebp,esp</span><br><span class="line">804e4666 8b4d08          mov     ecx,dword ptr [ebp+8]  ; 取第一个参数（线性地址）</span><br><span class="line">804e4669 8bc1            mov     eax,ecx                ; 赋值到中间变量，方便运算</span><br><span class="line">804e466b c1e814          shr     eax,14h                ; 逻辑右移20位</span><br><span class="line">804e466e bafc0f0000      mov     edx,0FFCh				</span><br><span class="line">804e4673 23c2            and     eax,edx                ; 和操作数进行与运算，同时清空最后2位；相当于做了一个乘4的运算，既左移2位</span><br><span class="line">804e4675 2d0000d03f      sub     eax,3FD00000h          ; 进行减法运算，相当于eax+0xC0300000</span><br><span class="line">804e467a 8b00            mov     eax,dword ptr [eax]    ; 取PDE的值</span><br><span class="line">804e467c a801            test    al,1                   ; 判断PDE属性P位是否为1</span><br><span class="line">804e467e 0f84d2f10000    je      nt!MmIsAddressValid+0x4f (804f3856)</span><br><span class="line">804e4684 84c0            test    al,al                  ; 判断下标为7的位(PS位)值是否为1</span><br><span class="line">804e4686 7824            js      nt!MmIsAddressValid+0x53 (804e46ac)</span><br></pre></td></tr></table></figure>

<h3 id="巧妙的与运算："><a href="#巧妙的与运算：" class="headerlink" title="巧妙的与运算："></a>巧妙的与运算：</h3><ol>
<li>首先将线性地址逻辑右移20位，此时还余下12位</li>
<li>将这12位和操作数0xFFC做一个与运算，0xFFC换算成2进制就是1111 1111 1100。因此做完与运算后，刚刚经过第一步操作还剩下12位的数的低2位，置0了。熟悉移位运算的朋友们知道，这个12位的数，相当于1个10位的数逻辑左移2位得到，换句话说就是将这个10位的数乘4。而这个10位，就是PDI，因此这步操作完了以后，相当于我们获得了PDI*4的值。</li>
<li>接下来，与0x3FD00000做减法运算，作用相当于加上0xC0300000，两种方法的结果是一样的。因此，我们得到了0xC0300000 + PDI*4的值，而这个值，恰恰就是我们要找的PDE，接着只需要取出里面的值，就可以获取PDE的属性了</li>
</ol>
<h3 id="后续跳转"><a href="#后续跳转" class="headerlink" title="后续跳转"></a>后续跳转</h3><p>再获取PDE的属性后，会遇到两个跳转，简单的概括下：</p>
<ol>
<li>首先会判断PDE下标为0的位置的值，也就是P位，当P位为0时，说明物理页无效，会跳转到一个相应的处理函数，这里就不再跟进分析</li>
<li>若物理页P位为1，就会来到第二个跳转，这里test al, al指令会修改标志寄存器，当al的最高位，也就是下标为7的位置值为1时，会被认为是负数，此时会修改EFLAG寄存器的SF位。这时，在第二个跳转的位置，js判断的就是SF的值是否为1，若为1，也就是al下标为7的位置值为1，这是对应的PDE属性PS位，说明这是一个4MB的大页，进而会跳转执行相应的处理函数。</li>
</ol>
<h2 id="获取PTE属性"><a href="#获取PTE属性" class="headerlink" title="获取PTE属性"></a>获取PTE属性</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">804e4688 c1e90a          shr     ecx,0Ah             ; 逻辑右移10位</span><br><span class="line">804e468b 81e1fcff3f00    and     ecx,3FFFFCh         ; 和操作数进行与运算，同时清空最后2位，相当于PDI左移12位+PTI左移2位</span><br><span class="line">804e4691 81e900000040    sub     ecx,40000000h       ; 进行减法运算，相当于eax+0xC0000000</span><br><span class="line">804e4697 8bc1            mov     eax,ecx</span><br><span class="line">804e4699 8b08            mov     ecx,dword ptr [eax] ; 获取PTE属性</span><br><span class="line">804e469b f6c101          test    cl,1                ; 判断P位的值是否为0</span><br><span class="line">804e469e 0f84b2f10000    je      nt!MmIsAddressValid+0x4f (804f3856)</span><br><span class="line">804e46a4 84c9            test    cl,cl               ; 判断PAT是值是否为1</span><br><span class="line">804e46a6 0f88b6de0300    js      nt!MmIsAddressValid+0x3f (80522562)</span><br><span class="line">804e46ac b001            mov     al,1</span><br><span class="line">804e46ae 5d              pop     ebp</span><br><span class="line">804e46af c20400          ret     4</span><br></pre></td></tr></table></figure>

<h3 id="巧妙的与运算"><a href="#巧妙的与运算" class="headerlink" title="巧妙的与运算"></a>巧妙的与运算</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and ecx, 3FFFFCh</span><br></pre></td></tr></table></figure>

<p>假设线性地址右移10位后的值为 0000 0000 00aa aaaa aaaa bbbb bbbb bbxx（a, b的值为0或者1，这里只是为了区分PDI和PTI）</p>
<p>然后我们来拆分0x3FFFFC的值：0000 0000 0011 1111 1111 1111 1111 1100</p>
<p>将两者进行与运算后得到结果为 0000 0000 00aa aaaa aaaa bbbb bbbb bb00</p>
<p>我们知道，aa aaaa aaaa应为PDI，而bb bbbb bbbb应为PTI，因此可以把得到的结果看作是这样的一个运算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aa aaaa aaaa&lt;&lt;12 + bb bbbb bbbb&lt;&lt;2</span><br><span class="line">= aa aaaa aaaa * 2^12 + bb bbbb bbbb * 2^2</span><br><span class="line">= aa aaaa aaaa * 1000h + bb bbbb bbbb * 4h</span><br><span class="line">= PDI*1000h + PTI*4h</span><br></pre></td></tr></table></figure>

<p>因此经过这个与运算后，再通过溢出进行减法运算，获取到PTE的所在位置，便可以取出属性</p>
<h3 id="后续跳转-1"><a href="#后续跳转-1" class="headerlink" title="后续跳转"></a>后续跳转</h3><p>经过最为关键的步骤，取到了PTE的属性后，还剩下两个跳转，这两个跳转的原理和上述的两个跳转完全一样，分别是取PTE下标为0的P位和下标为7的PAT位，区别仅仅在于，PDE和PTE的下标为7的位的含义不同，所以会跳转进入两个不同的处理函数，这里就不多做分析。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>今天的分析主要是弄清楚Windows系统函数是如何获取物理页属性的，同样是通过利用页目录表基址和页表基址，实现用线性地址访问PDE和PTE，在分析时看到，比较关键的一步是两个与运算，非常巧妙，之后再通过减法运算利用溢出达到和加法运算同样的效果，获取到PDE&#x2F;PTE的值。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>页目录&amp;页表基址</title>
    <url>/2022/03/20/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E9%A1%B5%E7%9B%AE%E5%BD%95%E8%A1%A8&amp;%E9%A1%B5%E8%A1%A8%E5%9F%BA%E5%9D%80/</url>
    <content><![CDATA[<blockquote>
<p>考虑这样一个问题，我们现在可以通过在Windbg里找到线性地址所在的物理页，通过修改物理页的属性，就可以实现一些原本受限的功能。例如将常量区对应的物理页R&#x2F;W属性修改为1，便可以修改位于常量区的元素。</p>
<p>但是，以上操作都是基于Windbg在双击调试的环境中实现的，那么一旦脱离了调试器，该如何通过代码来实现对物理页属性的修改呢？这就需要借助于页目录表基址和页表基址了。</p>
</blockquote>
<h2 id="页目录表基址"><a href="#页目录表基址" class="headerlink" title="页目录表基址"></a>页目录表基址</h2><p>结论：C0300000就是页目录表基址，接下来我们来验证这个结论。</p>
<h3 id="C0300000拆分"><a href="#C0300000拆分" class="headerlink" title="C0300000拆分"></a>C0300000拆分</h3><p>C0300000： 1100 0000 0011 0000 0000 0000 0000 0000</p>
<table>
<thead>
<tr>
<th>每部分位数</th>
<th>二进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>11 0000 0000</td>
<td>300</td>
</tr>
<tr>
<td>10</td>
<td>11 0000 0000</td>
<td>300</td>
</tr>
<tr>
<td>12</td>
<td>0000 0000 0000</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="Cr3"><a href="#Cr3" class="headerlink" title="Cr3"></a>Cr3</h3><p>这里以记事本(notepad.exe)为例，来验证一下，C0300000就是页目录表基址，首先查看记事本对应的Cr3指向的物理地址。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-12-35-af0a5d5b7923dd573fb3d855028827d3-pdtCr3-78a409.png" alt="img"></p>
<p>我们知道，Cr3指向的是PDT的首地址，这里可以看到4个PDE有值。</p>
<h3 id="查看C0300000物理页"><a href="#查看C0300000物理页" class="headerlink" title="查看C0300000物理页"></a>查看C0300000物理页</h3><p>接下来的步骤就是比较熟悉的，根据拆分后的线性地址，寻找物理页的过程了。但是这一次，要慢点看。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-12-52-9cbeb02851de3f150542cb2966906361-pdtPde-3ea291.png" alt="img"></p>
<p>这一步很容易理解，Cr3.base + 300*4，通过Cr3和线性地址的前10位，我们找到了PDE的值：7ea49063</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-13-03-9cbeb02851de3f150542cb2966906361-pdtPde-c1e116.png" alt="img"></p>
<p>什么？又重复了一遍？实际上不是，由于PDE的值为7ea49063，后12位是属性位，因此，7ea49000是我们要找的PTT的首地址，然后通过PTT.base + 300*4，就得到了PTE的值：7ea49063。</p>
<p>有了PTE的值，加上最后12位的偏移（此处为0），就可以找到物理页。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-13-21-a14aa5e484cdf9c52446f449fe68b380-pdtPte-9bc48f.png" alt="img"></p>
<p>得到结果后，是不是很惊讶？C0300000这个<strong>线性地址对应的物理页上的物理地址</strong>，竟然和Cr3指向的物理地址完全一样！也就是说，以后不需要Cr3，只需在当前程序内，通过C0300000这个线性地址就可以得到当前程序PDT的首地址了</p>
<h3 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h3><p>是啊，C0300000这个地址有啥用呢？当然有用，而且非常有用。回到文章开头的问题，我们该如何在不使用Windbg的情况下，修改物理页的属性呢？</p>
<p>我们知道，想要修改物理页的属性，需要先修改物理页对应的PDE和PTE，那要如何找到PDE和PTE呢，由于<strong>在编写代码时，用到的都是线性地址</strong>，而C0300000这个线性地址刚好就可以找到PDT的首地址，这样我们拆分想要修改的物理页属性的线性地址，将前10位加上C0300000即可找到对应的PDE。</p>
<p>既然PDE找到了，那不就有了PTT的首地址，这样PTE不也就可以找到了吗？并不是这样，尽管找到了PDE，但是由于<strong>PDE里面存着的是物理地址，如果直接访问PDE里面存的那个地址，在代码中会转变为一个线性地址</strong>，因此并不能通过PDE获取PTT的首地址，也就不能获取到PTE了，想要找到PTE，还得需要用到另外一个基地址，就是页表基址。</p>
<h2 id="页表基址"><a href="#页表基址" class="headerlink" title="页表基址"></a>页表基址</h2><p>还是直接上结论，页表基址：C0000000</p>
<p>接下来我们来验证。</p>
<h3 id="C0000000拆分"><a href="#C0000000拆分" class="headerlink" title="C0000000拆分"></a>C0000000拆分</h3><p>C0000000： 1100 0000 0000 0000 0000 0000 0000 0000</p>
<table>
<thead>
<tr>
<th>每部分位数</th>
<th>二进制</th>
<th>十六进制</th>
</tr>
</thead>
<tbody><tr>
<td>10</td>
<td>11 0000 0000</td>
<td>300</td>
</tr>
<tr>
<td>10</td>
<td>00 0000 0000</td>
<td>0</td>
</tr>
<tr>
<td>12</td>
<td>0000 0000 0000</td>
<td>0</td>
</tr>
</tbody></table>
<h3 id="Cr3-1"><a href="#Cr3-1" class="headerlink" title="Cr3"></a>Cr3</h3><p>这里还是以记事本(notepad.exe)为例：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-13-43-93925f55bcc80aeec601d2b6fb776733-pttCr3-a7d53d.png" alt="img"></p>
<p>我们查看Cr3指向的物理地址，当前共有4个PDE的有值的，而PDE的值，就是PTT的首地址，以第一个PDE（36c24067）为例，<strong>其中PTT的首地址为36c24000</strong>。</p>
<h3 id="查看C0000000物理页"><a href="#查看C0000000物理页" class="headerlink" title="查看C0000000物理页"></a>查看C0000000物理页</h3><p>步骤和之前一样，就直接看结果好了。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-13-59-4a3cfbb23500f11b6115328b7352592e-pttPte-2f9739.png" alt="img"></p>
<p>发现，C0000000这个线性地址所对应的物理页，刚好是36c24000，也就是第一个PDE对应的PTT的首地址。由此可以进一步推断，C0001000则是第二个PDE对应的PTT的首地址，以此类推。</p>
<h2 id="再看10-10-12分页"><a href="#再看10-10-12分页" class="headerlink" title="再看10-10-12分页"></a>再看10-10-12分页</h2><p>现在再来看10-10-12分页时，看法就会有所不一样了。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-21-00-14-13-2ddf8fc54f95bffe55fbdd3b95417dbc-10-10-12-54e377.png" alt="img"></p>
<ol>
<li>实际上页表（PTT）被映射到了从0xC0000000到0xC03FFFFF的4M地址空间</li>
<li>在这1024个表中有一张特殊的表：页目录表（PDT）</li>
<li>页目录表（PDT）被映射到了0xC030000开始处的4KB大小的地址空间</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="有了0xC0300000和0xC0000000能做什么？"><a href="#有了0xC0300000和0xC0000000能做什么？" class="headerlink" title="有了0xC0300000和0xC0000000能做什么？"></a>有了0xC0300000和0xC0000000能做什么？</h3><p>掌握了这两个地址，就掌握了一个进程所有的物理内存读写权限。</p>
<p>公式总结：</p>
<ul>
<li>什么是PDI和PTI？ 将32位线性地址拆分位10(PDI)-10(PTI)-12</li>
<li>访问页目录表(PDT)的公式：0xC0300000 + PDI x 4</li>
<li>访问页表(PTT)的公式：0xC0000000 + PDI x 1000 + PTI x 4（不用*号因为会被转义）</li>
</ul>
<h3 id="其它关于页的细节"><a href="#其它关于页的细节" class="headerlink" title="其它关于页的细节"></a>其它关于页的细节</h3><ul>
<li>高2G有一些大页，即4MB页</li>
<li>两个进程低2G几乎不同，高2G几乎相同</li>
<li>一个进程低2G的内存空间，前64K与后64K是没有使用的（线性地址0 - 00010000 与 7FFF0000 - 7FFFFFFFF）</li>
</ul>
<h3 id="谁填充了这些表呢"><a href="#谁填充了这些表呢" class="headerlink" title="谁填充了这些表呢"></a>谁填充了这些表呢</h3><p><strong>进程本身可以通过0xC0300000和0xC0000000访问修改任意物理页</strong>，那么是谁为我们填充0xC0300000和0xC0000000的PDE与PTE呢？</p>
<p>进程的创建过程：当创建B进程时，先在A进程中将B进程所有信息全部构建好，然后切换Cr3即可。也就是说，最开始的这张表是由A进程填充的。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>保护模式</tag>
      </tags>
  </entry>
  <entry>
    <title>API函数的调用过程（3环进0环）</title>
    <url>/2022/03/26/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%883%E7%8E%AF%E8%BF%9B0%E7%8E%AF%EF%BC%89/</url>
    <content><![CDATA[<p>上一篇中分析了ReadProcessMemory函数的3环部分，它实际上没有做太多工作，只是提供了一个调用0环函数的接口，今天我们接着向下分析，看看函数是如何进入0环的。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="KUSER-SHARED-DATA"><a href="#KUSER-SHARED-DATA" class="headerlink" title="_KUSER_SHARED_DATA"></a>_KUSER_SHARED_DATA</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-26-25-e0aa1cbe699ec4228d8a655bec22b19f-nrvm-ca13f1.png"></p>
<p>上一篇讲到了NtReadVirtualMemory这部分，调用了一个函数地址0x7FFE0300。那这个地址有什么用呢？这就要介绍一个新的结构_KUSER_SHARED_DATA：</p>
<ol>
<li>在User层和Kernel层分别定义了一个_KUSER_SHARED_DATA结构区域，用于User层和Kernel层共享某些数据</li>
<li>它们使用固定的地址值映射，_KUSER_SHARED_DATA结构区域在User和Kernel层地址分别为：<ul>
<li>User层地址为：0x7FFE0000</li>
<li>Kernel层地址为：0xFFDF0000</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-27-56-1fe10ed8bfc1a6205620f24b0f85028b-kusd-900487.png"></p>
<p><strong>注意</strong>：虽然指向的是同一个物理页，但在User层是只读的，在Kernel层是可写的</p>
<h3 id="SystemCall"><a href="#SystemCall" class="headerlink" title="SystemCall"></a>SystemCall</h3><p>现在我们知道，0x7FFE0000处是_KUSER_SHARED_DATA结构，使用dt指令查看结构，查找0x300偏移处，也就是0x7FFE0300的位置，这个字段是SystemCall</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-32-44-2958966e1321945bf0026aceea19d9e5-systemCall-229b7f.png"></p>
<p>那这个SystemCall有什么用呢？</p>
<p>SystemCall的作用是选择以什么方式进入0环。这要看CPU是否支持sysenter&#x2F;sysexit</p>
<ul>
<li>支持：ntdll.dll!KiFastSystemCall()</li>
<li>不支持：ntdll.dll!KiIntSystemCall()</li>
</ul>
<p>那如何看CPU是否支持sysenter&#x2F;sysexit指令呢？</p>
<ol>
<li>（OD打开任一程序）将eax置1（参数）</li>
<li>将ecx，edx置0（方便查看）</li>
<li>执行指令cpuid</li>
<li>查看edx的SEP位（下标11的位置），若值为1，说明支持sysenter&#x2F;sysexit</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-33-59-62d53dcb5ce2547ee6df9ad726b4c02c-cpuidBefore-0461cf.png"> <img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-34-05-4b3a7edeb89b88f495fd323d4162127c-cpuidAfter-d30ae8.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FBFF -&gt; 1111 1011 1111 1111  // 说明本机支持sysenter/sysexit</span><br></pre></td></tr></table></figure>

<h2 id="KiIntSystemCall进0环-中断门"><a href="#KiIntSystemCall进0环-中断门" class="headerlink" title="KiIntSystemCall进0环(中断门)"></a>KiIntSystemCall进0环(中断门)</h2><p>在学过调用门，中断门后，我们知道，凡是提权（例如进0环），都伴随着寄存器中的值发生改变，包括CS，SS，EIP，ESP。所以我们分别分析一下两种进0环方式，看看他们是如何修改寄存器的值的，先从KiIntSystemCall开始。</p>
<h3 id="获取提权后寄存器的值"><a href="#获取提权后寄存器的值" class="headerlink" title="获取提权后寄存器的值"></a>获取提权后寄存器的值</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-36-28-48500c2bc822157714751efd4d5978a9-kisc-325574.png"></p>
<p>KiIntSystemCall进0环的方式非常简单，就是我们最熟悉中断门。（这里第一条指令的作用是<strong>获取参数的首地址</strong>）</p>
<p>中断门就很熟悉了，进入IDT表看下0x2E对应的门描述符</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-37-30-5eef1172e8c784849e377680ce386301-0x2e-20a20e.png"></p>
<p>根据中断门描述符，可以很快得到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CS = 0x8 EIP = 8053e481</span><br></pre></td></tr></table></figure>

<p>至于SS，和ESP，会在程序提权时，由tr寄存器指向的TSS中的ESP0和SS0提供。</p>
<h3 id="KiSystemService"><a href="#KiSystemService" class="headerlink" title="KiSystemService"></a>KiSystemService</h3><p>根据EIP的值，0x8053e481我们可以定位到一个内核函数KiSystemService</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-38-30-52c21806a88c8797e077581859512f0e-kss-684454.png"></p>
<p>这样就说明进入0环了，所以KiIntSystemCall进0环非常好理解，就是中断门的知识，进入0环后，就跳转到KiSystemService继续执行，至于如何找到想要执行的函数，会在后面的文章中介绍。接下来我们来看支持sysenter&#x2F;sysexit的KiFastSystemCall是如何进入0环的。</p>
<h2 id="KiFastSystemCall进0环（快速调用）"><a href="#KiFastSystemCall进0环（快速调用）" class="headerlink" title="KiFastSystemCall进0环（快速调用）"></a>KiFastSystemCall进0环（快速调用）</h2><p>事实上，基本上现在的CPU都支持sysenter&#x2F;sysexit，默认也是通过KiFastSystemCall进0环，为什么呢？顾名思义，因为快啊。因为KiFastSystemCall不需要像中断门进0环时，去查IDT表找CS，EIP，查TSS找ESP和SS，而是直接从寄存器里读取这些数据。</p>
<h3 id="获取提权后寄存器的值-1"><a href="#获取提权后寄存器的值-1" class="headerlink" title="获取提权后寄存器的值"></a>获取提权后寄存器的值</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-39-36-891c22733bf2b54eb808bcad3cf1da6e-kfsc-dc4a74.png"></p>
<p>来看KiFastSystemCall，只有两行指令。sysenter指令，又称作快速调用，当CPU支持sysenter指令时，<strong>操作系统</strong>会提前将CS，SS，ESP，EIP写入到MSR寄存器中，当sysenter指令执行时，CPU直接从MSR中将这些值写入相应寄存器中，<strong>没有读取内存的过程</strong>，所以叫做快速调用。</p>
<h3 id="MSR寄存器"><a href="#MSR寄存器" class="headerlink" title="MSR寄存器"></a>MSR寄存器</h3><p>由于MSR寄存器非常大，这里不细讲，只列出用到的值</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-40-32-52a8b2a6fcee33cdb1ed1fe470ff6a0c-msr-54f99f.png"></p>
<p>可以通过RDMSR&#x2F;WRMST来进行读写（操作系统使用WRMST写该寄存器）</p>
<p>这里读取ESP，EIP，CS的值（<strong>SS的值可以通过CS+8计算而得</strong>）</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-41-16-8a6ccc5cc43ecf17f9601111b0631b53-msrValue-73019a.png"></p>
<p>这样，在进入0环时，便能通过MSR寄存器切换4个寄存器的值了</p>
<p><strong>注意</strong>：</p>
<ul>
<li>在执行<strong>sysenter</strong>指令时，只有<strong>CS</strong>、<strong>ESP</strong>、<strong>EIP</strong>三个寄存器的值可从MSR寄存器中获得，<strong>其中并不包括SS！</strong></li>
<li><code>SS</code>&#x3D; <strong>IA32_SYSENTER_CS</strong> + <strong>8</strong></li>
<li>这些操作与<strong>操作系统</strong>无关，而是<strong>硬件</strong>（CPU）做的<code>（参考Intel白皮书第二卷）</code></li>
</ul>
<h3 id="KiFastCallEntry"><a href="#KiFastCallEntry" class="headerlink" title="KiFastCallEntry"></a>KiFastCallEntry</h3><p>前面讲了KiIntSystemCall进入0环后执行KiSystemService，KiFastSystemCall当然也有，执行的是另一个函数，通过MSR得到的EIP我们可以找到函数KiFastCallEntry，同样是内核函数。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-26-22-43-35-42c332e010267abcb3471aa2284abfc0-kfce-0e98b3.png"></p>
<p>这样便成功进入0环了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>进0环的过程非常好理解，一种是咱们熟悉的中断门，另一种快速调用。</p>
<ol>
<li><strong>API通过中断门进0环</strong><ul>
<li>固定中断号为0x2E</li>
<li>CS&#x2F;EIP由门描述符提供，ESP&#x2F;SS由TSS提供</li>
<li>进入0环后执行的内核函数：NT!KiSystemService</li>
</ul>
</li>
<li><strong>API通过sysenter指令进0环</strong><ul>
<li>CS&#x2F;ESP&#x2F;EIP由MSR寄存器提供(SS是算出来的)</li>
<li>进入0环后执行的内核函数：NT!KiFastCallEntry</li>
</ul>
</li>
<li><strong>内核模块</strong><ul>
<li>10-10-12分页：ntoskrnl.exe</li>
<li>2-9-9-12分页：ntkrnlpa.exe</li>
</ul>
</li>
</ol>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>要求：</p>
<p>通过<strong>IDA</strong>找到<strong>KiSystemService</strong>和<strong>KiFastCallEntry</strong>函数并分析</p>
<p>问题：</p>
<ol>
<li>进0环后，<strong>原来的寄存器</strong>存在哪里？</li>
<li>如何根据<strong>系统调用号</strong>(eax中存储)找到要执行的内核函数？</li>
<li>调用时<strong>参数</strong>是存储到3环的堆栈，<strong>如何传递</strong>给内核函数？</li>
<li>2种调用方式是<strong>如何返回</strong>到3环的？</li>
</ol>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
        <tag>x86</tag>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title>API函数的调用过程（保存现场）</title>
    <url>/2022/03/27/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E4%BF%9D%E5%AD%98%E7%8E%B0%E5%9C%BA%EF%BC%89/</url>
    <content><![CDATA[<p>现在我们知道如何进入0环了，有两种方式，通过中断门（KiSystemService）或者快速调用（KiFastCallEntry）。上一篇中最后留下了几个问题，其中一个就是关于<strong>如何保存那些3环寄存器原先的值</strong>（俗称保存现场），从而能够在执行完0环实现的功能后，顺利的返回到3环，今天我们就来探究一下这个问题，首先我们来认识几个结构：Trap_Frame、ETHREAD、KTHREAD、KPCR</p>
<h2 id="Trap-Frame"><a href="#Trap-Frame" class="headerlink" title="_Trap_Frame"></a>_Trap_Frame</h2><p>在Windbg中通过dt _KTrap_Frame进行查看</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-27-22-34-57-e25c585a64bd8e4ee42798d9bd00576c-trapFrame-f45bad.png"></p>
<ul>
<li>（0x7c~0x88）在保护模式下没有被使用，只在<strong>虚拟8086模式</strong>中用得到</li>
<li>（0x68~0x78）<strong>中断门</strong>进0环时，用于存储3环的CS，SS，ESP，EIP，EFLAGS</li>
<li>（0x48~0x64）保存现场</li>
<li>（0x00~0x44）调式及其它作用</li>
</ul>
<p>简要介绍完了Trap_Frame结构，了解了这是<strong>保存现场</strong>用到的结构，后面在分析KiSystemService时，会介绍保存现场的主要过程。</p>
<h2 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h2><p>ETHREAD（执行体线程块）是执行体层上的线程对象的数据结构。在Windows内核中，每个进程的每一个线程都对应着一个ETHREAD数据结构。</p>
<p>在Windbg中通过dt _ETHREAD进行查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x1c0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x1c0 NestedFaultCount : Pos 0, 2 Bits</span><br><span class="line">   +0x1c0 ApcNeeded        : Pos 2, 1 Bit</span><br><span class="line">   +0x1c8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x1c8 LpcReplyChain    : _LIST_ENTRY</span><br><span class="line">   +0x1c8 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x1d0 ExitStatus       : Int4B</span><br><span class="line">   +0x1d0 OfsChain         : Ptr32 Void</span><br><span class="line">   +0x1d4 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x1dc TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x1dc ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x1dc KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x1e0 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x1e4 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x1ec Cid              : _CLIENT_ID</span><br><span class="line">   +0x1f4 LpcReplySemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x208 LpcReplyMessage  : Ptr32 Void</span><br><span class="line">   +0x208 LpcWaitingOnPort : Ptr32 Void</span><br><span class="line">   +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION</span><br><span class="line">   +0x210 IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x218 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x21c DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x220 ThreadsProcess   : Ptr32 _EPROCESS</span><br><span class="line">   +0x224 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x228 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x228 LpcReceivedMessageId : Uint4B</span><br><span class="line">   +0x22c ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x234 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x238 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x23c LpcReplyMessageId : Uint4B</span><br><span class="line">   +0x240 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x244 GrantedAccess    : Uint4B</span><br><span class="line">   +0x248 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x248 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x248 DeadThread       : Pos 1, 1 Bit</span><br><span class="line">   +0x248 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x248 SystemThread     : Pos 4, 1 Bit</span><br><span class="line">   +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x248 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x248 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x248 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x24c SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x24c ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x24c MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x250 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit</span><br><span class="line">   +0x250 LpcExitThreadCalled : Pos 1, 1 Bit</span><br><span class="line">   +0x250 AddressSpaceOwner : Pos 2, 1 Bit</span><br><span class="line">   +0x254 ForwardClusterOnly : UChar</span><br><span class="line">   +0x255 DisablePageFaultClustering : UChar</span><br></pre></td></tr></table></figure>



<h2 id="KTHREAD"><a href="#KTHREAD" class="headerlink" title="KTHREAD"></a>KTHREAD</h2><p>ETHREAD结构内嵌了一个KTHREAD对象作为第一个数据成员，因此一个指向ETHREAD对象的指针同时也是一个指向KTHREAD对象的指针。</p>
<p>在Windbg中通过dt _KTHREAD进行查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _KTHREAD</span><br><span class="line">ntdll!_KTHREAD</span><br><span class="line">   +0x000 Header           : _DISPATCHER_HEADER</span><br><span class="line">   +0x010 MutantListHead   : _LIST_ENTRY</span><br><span class="line">   +0x018 InitialStack     : Ptr32 Void</span><br><span class="line">   +0x01c StackLimit       : Ptr32 Void</span><br><span class="line">   +0x020 Teb              : Ptr32 Void</span><br><span class="line">   +0x024 TlsArray         : Ptr32 Void</span><br><span class="line">   +0x028 KernelStack      : Ptr32 Void</span><br><span class="line">   +0x02c DebugActive      : UChar</span><br><span class="line">   +0x02d State            : UChar</span><br><span class="line">   +0x02e Alerted          : [2] UChar</span><br><span class="line">   +0x030 Iopl             : UChar</span><br><span class="line">   +0x031 NpxState         : UChar</span><br><span class="line">   +0x032 Saturation       : Char</span><br><span class="line">   +0x033 Priority         : Char</span><br><span class="line">   +0x034 ApcState         : _KAPC_STATE</span><br><span class="line">   +0x04c ContextSwitches  : Uint4B</span><br><span class="line">   +0x050 IdleSwapBlock    : UChar</span><br><span class="line">   +0x051 Spare0           : [3] UChar</span><br><span class="line">   +0x054 WaitStatus       : Int4B</span><br><span class="line">   +0x058 WaitIrql         : UChar</span><br><span class="line">   +0x059 WaitMode         : Char</span><br><span class="line">   +0x05a WaitNext         : UChar</span><br><span class="line">   +0x05b WaitReason       : UChar</span><br><span class="line">   +0x05c WaitBlockList    : Ptr32 _KWAIT_BLOCK</span><br><span class="line">   +0x060 WaitListEntry    : _LIST_ENTRY</span><br><span class="line">   +0x060 SwapListEntry    : _SINGLE_LIST_ENTRY</span><br><span class="line">   +0x068 WaitTime         : Uint4B</span><br><span class="line">   +0x06c BasePriority     : Char</span><br><span class="line">   +0x06d DecrementCount   : UChar</span><br><span class="line">   +0x06e PriorityDecrement : Char</span><br><span class="line">   +0x06f Quantum          : Char</span><br><span class="line">   +0x070 WaitBlock        : [4] _KWAIT_BLOCK</span><br><span class="line">   +0x0d0 LegoData         : Ptr32 Void</span><br><span class="line">   +0x0d4 KernelApcDisable : Uint4B</span><br><span class="line">   +0x0d8 UserAffinity     : Uint4B</span><br><span class="line">   +0x0dc SystemAffinityActive : UChar</span><br><span class="line">   +0x0dd PowerState       : UChar</span><br><span class="line">   +0x0de NpxIrql          : UChar</span><br><span class="line">   +0x0df InitialNode      : UChar</span><br><span class="line">   +0x0e0 ServiceTable     : Ptr32 Void</span><br><span class="line">   +0x0e4 Queue            : Ptr32 _KQUEUE</span><br><span class="line">   +0x0e8 ApcQueueLock     : Uint4B</span><br><span class="line">   +0x0f0 Timer            : _KTIMER</span><br><span class="line">   +0x118 QueueListEntry   : _LIST_ENTRY</span><br><span class="line">   +0x120 SoftAffinity     : Uint4B</span><br><span class="line">   +0x124 Affinity         : Uint4B</span><br><span class="line">   +0x128 Preempted        : UChar</span><br><span class="line">   +0x129 ProcessReadyQueue : UChar</span><br><span class="line">   +0x12a KernelStackResident : UChar</span><br><span class="line">   +0x12b NextProcessor    : UChar</span><br><span class="line">   +0x12c CallbackStack    : Ptr32 Void</span><br><span class="line">   +0x130 Win32Thread      : Ptr32 Void</span><br><span class="line">   +0x134 TrapFrame        : Ptr32 _KTRAP_FRAME</span><br><span class="line">   +0x138 ApcStatePointer  : [2] Ptr32 _KAPC_STATE</span><br><span class="line">   +0x140 PreviousMode     : Char</span><br><span class="line">   +0x141 EnableStackSwap  : UChar</span><br><span class="line">   +0x142 LargeStack       : UChar</span><br><span class="line">   +0x143 ResourceIndex    : UChar</span><br><span class="line">   +0x144 KernelTime       : Uint4B</span><br><span class="line">   +0x148 UserTime         : Uint4B</span><br><span class="line">   +0x14c SavedApcState    : _KAPC_STATE</span><br><span class="line">   +0x164 Alertable        : UChar</span><br><span class="line">   +0x165 ApcStateIndex    : UChar</span><br><span class="line">   +0x166 ApcQueueable     : UChar</span><br><span class="line">   +0x167 AutoAlignment    : UChar</span><br><span class="line">   +0x168 StackBase        : Ptr32 Void</span><br><span class="line">   +0x16c SuspendApc       : _KAPC</span><br><span class="line">   +0x19c SuspendSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1b0 ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x1b8 FreezeCount      : Char</span><br><span class="line">   +0x1b9 SuspendCount     : Char</span><br><span class="line">   +0x1ba IdealProcessor   : UChar</span><br><span class="line">   +0x1bb DisableBoost     : UChar</span><br></pre></td></tr></table></figure>

<p>大致先解下这些结构即可，后续在介绍到线程与进程处时，会慢慢分析各个字段。</p>
<h2 id="KPCR"><a href="#KPCR" class="headerlink" title="KPCR"></a>KPCR</h2><p>描述：</p>
<ol>
<li>全称为CPU控制区（Processor Control Region）</li>
<li>每一个CPU都有一个CPU控制区，跟TLB一样，一核一个KPCR</li>
</ol>
<p>指令：</p>
<ul>
<li>dt _KPCR：查看KPCR结构</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0: kd&gt; dt _KPCR</span><br><span class="line">nt!_KPCR</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x01c SelfPcr          : Ptr32 _KPCR</span><br><span class="line">   +0x020 Prcb             : Ptr32 _KPRCB</span><br><span class="line">   +0x024 Irql             : UChar</span><br><span class="line">   +0x028 IRR              : Uint4B</span><br><span class="line">   +0x02c IrrActive        : Uint4B</span><br><span class="line">   +0x030 IDR              : Uint4B</span><br><span class="line">   +0x034 KdVersionBlock   : Ptr32 Void</span><br><span class="line">   +0x038 IDT              : Ptr32 _KIDTENTRY</span><br><span class="line">   +0x03c GDT              : Ptr32 _KGDTENTRY</span><br><span class="line">   +0x040 TSS              : Ptr32 _KTSS</span><br><span class="line">   +0x044 MajorVersion     : Uint2B</span><br><span class="line">   +0x046 MinorVersion     : Uint2B</span><br><span class="line">   +0x048 SetMember        : Uint4B</span><br><span class="line">   +0x04c StallScaleFactor : Uint4B</span><br><span class="line">   +0x050 DebugActive      : UChar</span><br><span class="line">   +0x051 Number           : UChar</span><br><span class="line">   +0x052 Spare0           : UChar</span><br><span class="line">   +0x053 SecondLevelCacheAssociativity : UChar</span><br><span class="line">   +0x054 VdmAlert         : Uint4B</span><br><span class="line">   +0x058 KernelReserved   : [14] Uint4B</span><br><span class="line">   +0x090 SecondLevelCacheSize : Uint4B</span><br><span class="line">   +0x094 HalReserved      : [16] Uint4B</span><br><span class="line">   +0x0d4 InterruptMode    : Uint4B</span><br><span class="line">   +0x0d8 Spare1           : UChar</span><br><span class="line">   +0x0dc KernelReserved2  : [17] Uint4B</span><br><span class="line">   +0x120 PrcbData         : _KPRCB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>dd KeNumberProcessors：查看KPCR数量</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-21-44-01-58e9a0c04178bb1549a4dc1366079e2b-2022-07-27-23-44-35-58e9a0c04178bb1549a4dc1366079e2b-knp-0ae6ba-349c22.png"></p>
<p>由于当前虚拟机只分配了一个核，所以数量是1</p>
<ul>
<li>dd KiProcessorBlock：查看KPCR位置</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-27-23-45-14-cb7c32212e67dcfd2d962ed14a64241e-kpb-b8dbc5.png"></p>
<p>同理，因为单核，这里只显示了一个值，这个地址显示的是ffdff120，也就是KPCR偏移0x120的位置。KPCR偏移0x120的位置是 _KPRCB，可以理解为扩展的KPCR</p>
<h2 id="KiSystemService"><a href="#KiSystemService" class="headerlink" title="KiSystemService"></a>KiSystemService</h2><p>了解完上面介绍的结构，下面我们就可以分析一下0环函数KiSystemService，到底是如何保存现场的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nt!KiSystemService:</span><br><span class="line">80542451 6a00            push    0</span><br><span class="line">80542453 55              push    ebp</span><br><span class="line">80542454 53              push    ebx</span><br><span class="line">80542455 56              push    esi</span><br><span class="line">80542456 57              push    edi</span><br><span class="line">80542457 0fa0            push    fs</span><br><span class="line">80542459 bb30000000      mov     ebx,30h</span><br><span class="line">8054245e 668ee3          mov     fs,bx</span><br><span class="line">80542461 64ff3500000000  push    dword ptr fs:[0]</span><br><span class="line">80542468 64c70500000000ffffffff mov dword ptr fs:[0],0FFFFFFFFh</span><br><span class="line">80542473 648b3524010000  mov     esi,dword ptr fs:[124h]</span><br><span class="line">8054247a ffb640010000    push    dword ptr [esi+140h]</span><br><span class="line">80542480 83ec48          sub     esp,48h</span><br><span class="line">80542483 8b5c246c        mov     ebx,dword ptr [esp+6Ch]</span><br><span class="line">80542487 83e301          and     ebx,1</span><br><span class="line">8054248a 889e40010000    mov     byte ptr [esi+140h],bl</span><br><span class="line">80542490 8bec            mov     ebp,esp</span><br><span class="line">80542492 8b9e34010000    mov     ebx,dword ptr [esi+134h]</span><br><span class="line">80542498 895d3c          mov     dword ptr [ebp+3Ch],ebx</span><br><span class="line">8054249b 89ae34010000    mov     dword ptr [esi+134h],ebp</span><br><span class="line">805424a1 fc              cld</span><br><span class="line">805424a2 8b5d60          mov     ebx,dword ptr [ebp+60h]</span><br><span class="line">805424a5 8b7d68          mov     edi,dword ptr [ebp+68h]</span><br><span class="line">805424a8 89550c          mov     dword ptr [ebp+0Ch],edx</span><br><span class="line">805424ab c74508000ddbba  mov     dword ptr [ebp+8],0BADB0D00h</span><br><span class="line">805424b2 895d00          mov     dword ptr [ebp],ebx</span><br><span class="line">805424b5 897d04          mov     dword ptr [ebp+4],edi</span><br><span class="line">805424b8 f6462cff        test    byte ptr [esi+2Ch],0FFh</span><br><span class="line">805424bc 0f858afeffff    jne     nt!Dr_kss_a (8054234c)</span><br><span class="line">805424c2 fb              sti</span><br><span class="line">805424c3 e9e7000000      jmp     nt!KiFastCallEntry+0x8f (805425af)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数主体并不长，按照填充的结构不同我们来逐步分析。</p>
<h3 id="0x1"><a href="#0x1" class="headerlink" title="0x1"></a>0x1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80542451 6a00            push    0</span><br><span class="line">80542453 55              push    ebp</span><br><span class="line">80542454 53              push    ebx</span><br><span class="line">80542455 56              push    esi</span><br><span class="line">80542456 57              push    edi</span><br><span class="line">80542457 0fa0            push    fs</span><br></pre></td></tr></table></figure>

<p>首先来看这一段，为什么要push 0起手呢？ 这里先回顾一下Trap_Frame结构。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-27-23-57-10-e0cfec3598cb75189ef61b93e2e35324-0x1-954f89.png"></p>
<p>这是一个结构，换句话说，就是<strong>进入0环后的堆栈将会像这种形式组织起来</strong>，在刚进0环是，esp是位于 (0x78) 的位置，我们知道，通过中断门进0环时，会将3环的寄存器压栈，包括CS，SS，EIP，ESP和EFLAGS。因此在进入0环后，ESP的位置是位于 (0x68) 处。虽然2E号中断只会压入5个值，但是有些情况会压入6个值，而第6个值，就是ErrCode，为了对齐，保持堆栈平衡，操作系统这里会自己补一个0，这也就解释了为什么第一步是push 0。</p>
<p>接下来，就是保存ebp，ebx，esi，esi，fs依次压栈，保存到Trap_Frame结构中描述的位置。</p>
<h3 id="0x2"><a href="#0x2" class="headerlink" title="0x2"></a>0x2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80542459 bb30000000      mov     ebx,30h</span><br><span class="line">8054245e 668ee3          mov     fs,bx                          ; 写入fs段寄存器</span><br><span class="line">80542461 64ff3500000000  push    dword ptr fs:[0]               ; 保存旧的异常链表(ExceptionList)</span><br><span class="line">80542468 64c70500000000ffffffff mov dword ptr fs:[0],0FFFFFFFFh ; 将新的异常链表赋值为-1</span><br><span class="line">80542473 648b3524010000  mov     esi,dword ptr fs:[124h]        ; 获取当前线程KTHREAD</span><br><span class="line">8054247a ffb640010000    push    dword ptr [esi+140h]           ; 将先前模式(PreviousMode)压栈</span><br><span class="line">80542480 83ec48          sub     esp,48h                        ; 提升堆栈（栈顶执行Trap_Frame头）</span><br></pre></td></tr></table></figure>

<p>我们来看这部分做了什么事</p>
<ol>
<li>首先是将段选择子0x30写入fs段寄存器，根据段选择子确定段描述符，然后可以发现fs指向的地方(0xffdff000)刚好是KPCR这个结构。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-04-00-bab11146a414e212e432b33c7fc3a052-image-20220731220400554-df3357.png"></p>
<ol start="2">
<li>然后压栈了KPCR首地址位置的值，可以发现，KPCR首地址位置存的是异常链表(ExceptionList)，这里<strong>压栈了旧的异常链表</strong>，并将异常链表的值置为-1。至于异常链表的结构，留到后面再讲。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-06-49-b831c4b4c0abe7d270af607f6a66aa74-image-20220731220649898-6cdd04.png"></p>
<ol start="3">
<li>接着获取到KPCR + 0x124位置的值，并存入esi，然后将esi+0x140处的值压栈</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-11-04-98afc434381d1df78d00ac85163dcde9-image-20220731221104023-23bd1e.png"></p>
<p>可以发现<strong>KPCR+0x124处（赋给esi）</strong>的值，存的是<strong>当前线程（CurrentThread）的KTHREAD</strong>，我们再找到**(esi)KTHREAD+0x140<strong>偏移，发现压栈的字段叫做</strong>先前模式**（PerviousMode)</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-14-53-20c98b34703dfb51be471e049ea9df2a-image-20220731221453297-6b71ae.png" alt="image-20220731221453297"></p>
<ol start="4">
<li>最后提升堆栈0x48个字节</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-27-23-57-37-d4b5bad0f4fd1534a21fe0e80df193d0-0x2_conclusion-4bbd40.png"></p>
<p>经过这一部分的操作后，堆栈栈顶刚好指向_Trap_Frame的首地址，并<strong>完成了异常链表和先前模式的压栈操作</strong>。</p>
<h3 id="0x3"><a href="#0x3" class="headerlink" title="0x3"></a>0x3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">80542483 8b5c246c        mov     ebx,dword ptr [esp+6Ch]  ; 取进入中断门压栈的CS</span><br><span class="line">80542487 83e301          and     ebx,1					  ; 计算出调用中断门前的权限</span><br><span class="line">8054248a 889e40010000    mov     byte ptr [esi+140h],bl   ; 重新填写KTHREAD中的先前模式	</span><br><span class="line">80542490 8bec            mov     ebp,esp                  ; 让ebp指向_Trap_Frame首地址</span><br><span class="line">80542492 8b9e34010000    mov     ebx,dword ptr [esi+134h]</span><br><span class="line">80542498 895d3c          mov     dword ptr [ebp+3Ch],ebx  ; 将旧的_Trap_Frame保存到edx中</span><br><span class="line">8054249b 89ae34010000    mov     dword ptr [esi+134h],ebp ; 更新_Trap_Frame</span><br><span class="line">805424a1 fc              cld</span><br></pre></td></tr></table></figure>

<p>继续分析这一部分</p>
<ol>
<li>我们来看前3行，它做了什么事呢，先取出_Trap_Frame 0x6C偏移处的值，即进入中断门前，程序CS的值，然后和1进行了与运算，并将bl的值，填入上面提到的先前模式。为什么和1进行与运算就可以算出先前模式呢？难道不直接填3吗？首先我们知道，Windows只用了0环和3环，其次，<strong>即使执行中断门，执行前的程序也可以是0环程序</strong>，所以保守起见，这里和CPL的最低位进行与运算；若结果为1，说明是3环程序执行了中断门，若为0，说明是0环程序执行的中断门。从而算出先前模式，并填入到<strong>当前线程KTHREAD</strong>的先前模式字段中。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-36-29-2f1afc31b716cb833e4765156a1bbda4-image-20220731223629362-72911e.png" alt="image-20220731223629362"></p>
<ol start="2">
<li>上面3行更新了先前模式，接下来4行的作用就是<strong>更新了_Trap_Frame</strong>，我们知道栈顶指向Trap_Frame的首地址，现在让栈底也指向Trap_Frame的首地址，便于寻址。由0x2的分析可知esi指向KTHREAD，<strong>KTHREAD+0x134则指向Trap_Frame</strong>，这里的Trap_Frame是旧的地址（这里则是Null)，因此将它保存至堆栈，再将现在的Trap_Frame的地址写入，也就完成了更新。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-33-01-31ecc532d91d5c63dc092503b805e245-image-20220731223301474-f53b5a.png"></p>
<ol start="3">
<li>cld指令修改了EFLAGS寄存器的DF位</li>
</ol>
<h3 id="0x4"><a href="#0x4" class="headerlink" title="0x4"></a>0x4</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">805424a2 8b5d60          mov     ebx,dword ptr [ebp+60h]      ; 取3环的ebp给ebx</span><br><span class="line">805424a5 8b7d68          mov     edi,dword ptr [ebp+68h]      ; 取3环的eip给edi</span><br><span class="line">805424a8 89550c          mov     dword ptr [ebp+0Ch],edx      ; edx存的是3环第一个参数的地址，赋到_Trap_Frame的DbgArgPointer的位置</span><br><span class="line">805424ab c74508000ddbba  mov     dword ptr [ebp+8],0BADB0D00h ; 将操作系统用的标志赋给DbgArgMark</span><br><span class="line">805424b2 895d00          mov     dword ptr [ebp],ebx          ; 将3环的ebp赋值到DbgEbp</span><br><span class="line">805424b5 897d04          mov     dword ptr [ebp+4],edi        ; 将3环的eip赋值到DbgEip</span><br><span class="line">805424b8 f6462cff        test    byte ptr [esi+2Ch],0FFh      ; 判断DebugActive处的值是否为-1</span><br><span class="line">805424bc 0f858afeffff    jne     nt!Dr_kss_a (8054234c)       ; 跳转至调试寄存器保存函数</span><br><span class="line">805424c2 fb              sti</span><br><span class="line">805424c3 e9e7000000      jmp     nt!KiFastCallEntry+0x8f (805425af)</span><br></pre></td></tr></table></figure>

<p>来看最后一部分</p>
<ol>
<li>前6行，很好理解，主要是对_Trap_Frame调试部分的填充，一张图就可以概括<img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-28-22-31-48-88c708b22fd34dbe46489f2286ebc8a2-0x4_1-9530ea.png"></li>
<li>接下来的两行，会比较esi+0x2C的位置是否为-1，这个地方值如果不是-1，说明处于调试状态，紧接着会跳转到Dr_kss_a这个例程里，这个例程作用是将Dr0~Dr7这些调试寄存器的值保存到_Trap_Frame中，用于调试。同样的，了解了这个字段后，我们可以写一个程序，不断的修改这个值，将DebugActive这个值置为-1，这样程序就不会保存调试寄存器，也就无法调试，这是一种反调试的手段。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-07-31-22-40-29-eb477531b534d11efa3d9626ae071e01-image-20220731224029738-c101a5.png" alt="image-20220731224029738"> </p>
<ol start="3">
<li>最后，程序会跳转到<strong>KiFastCallEntry+0x8D</strong>这个位置继续执行，而这个位置，也是KiFastCallEntry执行完后跳转的地方。之所以分了两种方式，是因为中断门进0环时，压栈了5个值（ESP，EIP，CS，SS，EFLAGS）而快速调用没有，导致它们在<strong>填写_Trap_Frame结构的方式不同</strong>，但是在填完后，保存现场以后，后面执行的函数就一样了。</li>
</ol>
<h2 id="KiFastCallEntry"><a href="#KiFastCallEntry" class="headerlink" title="KiFastCallEntry"></a>KiFastCallEntry</h2><p>KiFastCallEntry保存现场的方式略微发杂，因为没有通过中断门对3环的5个寄存器进行压栈。</p>
<p>KiFastCallEntry要分为两个部分来看，第一个部分，是和KiSystemService所做的一样，对_Trap_Frame结构的填充，进行保存现场。完了之后，第二个部分，从<strong>KiFastCallEntry+0x8D</strong>开始，这是KiSystemService执行完后跳转的地方，也是KiFastCallEntry顺序执行的地方，是双方都要执行的代码，这也意味着，从这个地方开始，两种进0环的方式就统一了。</p>
<p>本篇只介绍第一部分，看看KiFastCallEntry在填充_Trap_Frame时与KiSystemService有何不同吧。</p>
<h3 id="0x1-1"><a href="#0x1-1" class="headerlink" title="0x1"></a>0x1</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0040689F	mov	ecx, 23h            ; ECX = 0x23</span><br><span class="line">.text:004068A4	push	30h             ; 通过堆栈的入栈和出栈加载fs</span><br><span class="line">.text:004068A6	pop     fs              ; 加载fs段寄存器：GDT表下标为6的段描述符</span><br></pre></td></tr></table></figure>

<p>在WinDbg中查看GDT表下标为6的段描述符：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-05-22-41-13-c43fb92c43f92fea21f00ea15f9fc890-20191108153226398-c13727.png"></p>
<p>可以看到段描述符：<code>ffc093df f000000</code> 指向 fs.Base: 0xffdff000，这个就是KPCR的地址</p>
<p>这里就先分析到这，至于从<strong>KiFastCallEntry+0x8D</strong>开始的第二部分，由于是KiSystemService和KiFastCallEntry的公共代码，两种进0环的方式都会执行，就不再本篇中分析了，留到下一篇介绍系统服务表和SSDT时再介绍。</p>
<h3 id="0x2-1"><a href="#0x2-1" class="headerlink" title="0x2"></a>0x2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:004068A8	mov     ds, ecx                 ; RPL=3；TI=0；INDEX=4</span><br><span class="line">                                                ; 加载GDT表下标为4的段描述符给ds</span><br><span class="line">.text:004068AA	mov     es, ecx                 ; 加载GDT表下标为4的段描述符给es</span><br></pre></td></tr></table></figure>

<p>在WinDbg中查看GDT表下标为4的段描述符：<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-05-22-48-59-f6eb6b21800141c9a70ceb1d9c8471f5-2019110915221945-66987c.png"></p>
<h3 id="0x3-1"><a href="#0x3-1" class="headerlink" title="0x3"></a>0x3</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:004068AC	mov     ecx, large fs:40h           ; ECX = TSS指针</span><br><span class="line">                                                    ; nt!_KPCR</span><br><span class="line">                                                    ; +0x040 TSS : Ptr32 _KTSS</span><br><span class="line">.text:004068B3	mov     esp, [ecx+4]                ; nt!_KTSS</span><br><span class="line">                                                    ; +0x004 Esp0  : Uint4B</span><br><span class="line">.text:004068B6  push    23h                         ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x078 HardwareSegSs : Uint4B</span><br><span class="line">.text:004068B8  push    edx                         ; edx保存的是3环参数的指针</span><br><span class="line">                                                    ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x074 HardwareEsp : Uint4B</span><br><span class="line">.text:004068B9  pushf                               ; 旧的标志寄存器入栈</span><br><span class="line">.text:004068BA  push    2                           ; 新的标志寄存器的值入栈</span><br><span class="line">.text:004068BC  add     edx, 8</span><br><span class="line">.text:004068BF  popf                                ; 新的标志寄存器的值出栈</span><br><span class="line">                                                    ; EFlags =  2，即第二位置1，其它位清零</span><br><span class="line">.text:004068C0   or      [esp+0Ch+var_B], 2</span><br><span class="line">.text:004068C5   push    1Bh                        ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x06c SegCs : Uint4B</span><br><span class="line">.text:004068C7   push    dword ptr ds:0FFDF0304h    ; +0x068 Eip : Uint4B</span><br><span class="line">.text:004068CD   push    0                          ; +0x064 ErrCode : Uint4B</span><br><span class="line">.text:004068CF   push    ebp                        ; +0x060 Ebp : Uint4B</span><br><span class="line">.text:004068D0   push    ebx                        ; +0x05c Ebx : Uint4B</span><br><span class="line">.text:004068D1   push    esi                        ; +0x058 Esi : Uint4B</span><br><span class="line">.text:004068D2   push    edi                        ; +0x054 Edi : Uint4B</span><br><span class="line">.text:004068D3   mov     ebx, large fs:1Ch          ; nt!_KPCR</span><br><span class="line">                                                    ; +0x01c SelfPcr : Ptr32 _KPCR</span><br><span class="line">                                                    ; 指向当前 KPCR 结构体本身，目的是方便查找</span><br><span class="line">.text:004068DA   push    3Bh                        ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x050 SegFs : Uint4B</span><br><span class="line">.text:004068DC   mov     esi, [ebx+124h]            ; nt!_KPCR</span><br><span class="line">                                                    ; +0x120 +0x4 CurrentThread : Ptr32 _KTHREAD</span><br><span class="line">                                                    ; 存储了当前正在跑的线程的信息，为 KTHREAD 结构体</span><br><span class="line">.text:004068E2   push    dword ptr [ebx]            ; ebx 保存的是KPCR结构体的地址</span><br><span class="line">                                                    ; KPCR 第一个成员为结构体 NT_TIB 的指针</span><br><span class="line">                                                    ; NT_TIB 的第一个值为 ExceptionList（异常列表）</span><br><span class="line">                                                    ; 这句话的目的是将异常列表保存到TrapFrame结构体中</span><br><span class="line">                                                    ; nt!_KPCR</span><br><span class="line">                                                    ; +0x000 NtTib : _NT_TIB</span><br><span class="line">                                                    ; nt!_NT_TIB</span><br><span class="line">                                                    ; +0x000 ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">                                                    ;</span><br><span class="line">                                                    ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x04c ExceptionList : Ptr32 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">.text:004068E4   mov  dword ptr [ebx], 0FFFFFFFFh   ; 将 ExceptionList（异常列表）置为 -1</span><br><span class="line">.text:004068EA   mov  ebp, [esi+18h]                ; nt!_KTHREAD</span><br><span class="line">                                                    ; +0x018 InitialStack : Ptr32 Void</span><br><span class="line">.text:004068ED   push    1                          ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x048 PreviousPreviousMode : Uint4B</span><br><span class="line">                                                    ; 往栈中压入老的先前模式，1表示先前模式为3环</span><br><span class="line">.text:004068EF   sub     esp, 48h                   ; 执行前，ESP位于_KTRAP_FRAME + 0x48 = PreviousPreviousMode</span><br><span class="line">                                                    ; 执行后，ESP 等于 _KTRAP_FRAME 结构指针</span><br><span class="line">.text:004068F2   sub     ebp, 29Ch</span><br><span class="line">.text:004068F8   mov     byte ptr [esi+140h], 1     ; 新的先前模式</span><br><span class="line">                                                    ; nt!_KTHREAD</span><br><span class="line">                                                    ; +0x140 PreviousMode : Char</span><br><span class="line">.text:004068FF   cmp     ebp, esp                   ; 检查 ebp 是否等于 esp（_KTRAP_FRAME 结构指针）</span><br><span class="line">.text:00406901   jnz     loc_40686C                 ; 若不等于，则跳转，进行异常处理</span><br><span class="line">.text:00406907   and     dword ptr [ebp+2Ch], 0     ; 修改 TrapFrame 结构体中 Dr7 的值</span><br><span class="line">                                                    ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x02c Dr7 : Uint4B</span><br><span class="line">.text:0040690B   test    byte ptr [esi+2Ch], 0FFh   ; 检测当前进程是否处于调试状态</span><br><span class="line">                                                    ; nt!_KTHREAD</span><br><span class="line">                                                    ; +0x02c DebugActive : UChar</span><br><span class="line">                                                    ; 若不处于调试状态，则 DebugActive 的值为FF</span><br><span class="line">.text:0040690F   mov     [esi+134h], ebp            ; 将 TrapFrame 结构指针写入当前线程信息中</span><br><span class="line">                                                    ; nt!_KTHREAD</span><br><span class="line">                                                    ; +0x134 TrapFrame : Ptr32 _KTRAP_FRAME</span><br><span class="line">.text:00406915   jnz     Dr_FastCallDrSave          ; 若当前进程处于被调试状态，则跳转，为 Dr0 ~ Dr7 进行赋值</span><br><span class="line">                                                    ; 若当前进程不处于被调试状态，则继续向下执行</span><br><span class="line">.text:0040691B   mov     ebx, [ebp+60h]             ; 从 TrapFrame 结构体中取出 Ebp 到 ebx 寄存器</span><br><span class="line">.text:0040691E   mov     edi, [ebp+68h]             ; 从 TrapFrame 结构体中取出 Eip 到 edi 寄存器</span><br><span class="line">.text:00406921   mov     [ebp+0Ch], edx             ; nt!_KTRAP_FRAME</span><br><span class="line">                                                    ; +0x000 DbgEbp : Uint4B</span><br><span class="line">.text:00406924   mov     dword ptr [ebp+8], 0BADB0D00h  ; +0x008 DbgArgMark : Uint4B</span><br><span class="line">.text:0040692B   mov     [ebp+0], ebx                   ; +0x000 DbgEbp : Uint4B</span><br><span class="line">.text:0040692E   mov     [ebp+4], edi                   ; +0x004 DbgEip : Uint4B</span><br><span class="line">.text:00406931   sti                                    ; 关闭中断</span><br><span class="line">.text:00406932                                          ; KiSystemService 与 KiFastCallEntry 函数的共同代码部分</span><br><span class="line">                                                        ; 下篇学习系统服务表时再进行分析</span><br></pre></td></tr></table></figure>





<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一篇通过学习_Trap_Frame，KTHREAD，KPCR这些结构，分析KiSystemService&amp;KiFastCallEntry了解了在进入0环后，保存现场的方式。尽管采用了两种不同的手段，但是思路总体来说是一样的，就是通过填充Trap_Frame结构完成3环寄存器的保存。</p>
<p>这两者之间不同点在于：</p>
<ol>
<li><p>当程序通过中断门从3环进入0环时，ESP指向TrapFrame+0x64的位置</p>
</li>
<li><p>当程序通过快速调用从3环进入0环时，ESP指向TrapFrame+0x78的位置</p>
</li>
<li><p>若通过中断门进入0环，在KiSystemService函数开始执行时，3环的SS、ESP、EFLAGS、CS、EIP就已经被存储到 TrapFrame 结构体中了</p>
</li>
<li><p>TrapFrame 结构体的其它成员通过 KiSystemService 和 KiFastCallEntry 进行赋值</p>
</li>
</ol>
<p>不管是 KiSystemService 还是 KiFastCallEntry，最终都要执行一部分相同的代码，分为两个函数是因为进入0环时，堆栈里的值不一样，走同一条函数会出问题。</p>
<p>在下一篇中，我们将继续探究，在保存完现场后，程序是如何找到想要执行的函数的。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
        <tag>x86</tag>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title>API函数的调用过程（系统服务表）</title>
    <url>/2022/03/28/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/API%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%A1%A8%EF%BC%89/</url>
    <content><![CDATA[<p>前面的学习过程中，我们了解到程序进入0环后，有一个保存现场的过程，会将3环的各种寄存器都保存到一个叫做_Trap_Frame的结构体中。在3环部分，程序将一个编号存到了<strong>eax中</strong>，这个编号叫做<strong>系统服务号</strong>，此外，在保存现场的过程中，程序还让<strong>edx指向了3环第一个参数的地址</strong>。回忆起这两步，接下来，就可以继续探究执行内核函数的过程了。</p>
<h2 id="系统服务表"><a href="#系统服务表" class="headerlink" title="系统服务表"></a>系统服务表</h2><p>在分析代码前，我们先来学习一个结构，系统服务表（System Service Table）</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-02-21-53-34-6d46cda21d005f57e3f330cd41564596-sst-e472f9.png"></p>
<p>在Windows XP系统下，系统服务表有两张，这两张表存着<strong>内核文件</strong>的导出函数（不包括内核文件的所有函数，主要是3环函数常用的内核函数）。第一张表导出的内核函数主要来源于ntoskrl.exe，实现大部分3环函数基本功能；第二张表导出的内核函数主要来源于win32k.sys，主要实现图形界面相关功能（例如GDI32.dll的底层实现）。</p>
<h3 id="系统服务表结构"><a href="#系统服务表结构" class="headerlink" title="系统服务表结构"></a>系统服务表结构</h3><p>根据示例图，我们先简单认识一下系统服务表，先从结构看起：</p>
<ul>
<li>ServiceTable：指向一个<strong>函数地址表</strong>，通过<strong>系统服务号</strong>可以在函数地址表中找到指定的内核函数。</li>
<li>Count：指当前系统服务表<strong>被调用的次数</strong>。</li>
<li>ServiceLimit：函数地址表的大小，即系统服务函数的个数</li>
<li>ArgmentTable：系统服务函数参数的大小，<strong>以字节为单位</strong>，每个成员大小为1个字节。</li>
</ul>
<h3 id="系统服务表位置"><a href="#系统服务表位置" class="headerlink" title="系统服务表位置"></a>系统服务表位置</h3><p>这个系统服务表<strong>位于KTHREAD结构的0xE0</strong>偏移处。这样，在进入0环后我们可以通过fs:[0]找到KPCR结构，然后在KPCR-&gt;0x124找到当前线程的KTHREAD结构，再根据KTHREAD-&gt;0xE0就可以找到当前线程所拥有的系统服务表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fs:[0] -&gt; KPCR -&gt; KPCR+0x124 -&gt; KTHREAD -&gt; KTHREAD+0xE0 -&gt; 系统服务表</span><br></pre></td></tr></table></figure>

<h3 id="系统服务号"><a href="#系统服务号" class="headerlink" title="系统服务号"></a>系统服务号</h3><p>系统服务号用来定位所要寻找的系统服务表的函数。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-02-21-57-10-e348d399fcc84e5e96232785c4acd6ae-ssn-786a07.png"></p>
<p>系统服务号只有低13位是有用的</p>
<ul>
<li>下标12：判断去查服务表，0去查第一张表；1去查第二张表</li>
<li>下标0~11：函数地址表的索引</li>
</ul>
<h2 id="SharedCode分析"><a href="#SharedCode分析" class="headerlink" title="SharedCode分析"></a>SharedCode分析</h2><p>在前面保存现场的代码分析中，由于进入0环的方式不同，中断进0环（int 2E）和快速调用（sysenter）保存现场的方式也不一样，但是当这两种方式，将寄存器保存到_Trap_Frame结构中以后（保存现场），便会从同一个地放（<strong>KiFastCallEntry+0x8D</strong>）开始执行，我们把这一部分共同的代码称作SharedCode（引用Joney的文中的称呼），接下来，我们简要分析一下SharedCode到底做了什么事。</p>
<p>这里还是将代码放在一起分析，更有连贯性，具体细节可以到Windbg中动手实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">804df781 8bf8            mov     edi,eax                  ; eax保存的是系统服务号(参考3环部分)，edi获取服务号</span><br><span class="line">804df783 c1ef08          shr     edi,8                    ; 将edi右移8位，系统服务号只用到13位，这样还剩下5位</span><br><span class="line">804df786 83e730          and     edi,30h                  ; 将余下的5位与0x30(0011 0000)进行与运算</span><br><span class="line">                                                          ; 得到的结果只有可能是0x10或者0</span><br><span class="line">                                                          ; 这里非常巧妙，因为0x10刚好是16个字节</span><br><span class="line">804df789 8bcf            mov     ecx,edi                  ; 将与后的结果，赋值给ecx</span><br><span class="line">804df78b 03bee0000000    add     edi,dword ptr [esi+0E0h] ; esi指向KTHREAD</span><br><span class="line">                                                          ; [esi+0xE]获取第一个系统服务表的首地址加上edi</span><br><span class="line">                                                          ; 如果edi的值是0x10，运算后就会指向第二个系统服务表的首地址</span><br><span class="line">804df791 8bd8            mov     ebx,eax                  ; ebx获取服务号</span><br><span class="line">804df793 25ff0f0000      and     eax,0FFFh                ; 对服务号进行与运算，上面的步骤已经确定了从哪一个系统服务表里找</span><br><span class="line">                                                          ; 这里将下标12的位置零，获取在函数地址表里的索引</span><br><span class="line">804df798 3b4708          cmp     eax,dword ptr [edi+8]    ; [edi+8]指向ServiceLimit，</span><br><span class="line">                                                          ; 这里与系统服务号作比较，防止系统符服务号越界</span><br><span class="line">804df79b 0f8341fdffff    jae     nt!KiBBTUnexpectedRange (804df4e2) ; 若越界则跳转异常处理</span><br><span class="line">804df7a1 83f910          cmp     ecx,10h                            ; 这里判断系统服务号属于哪个表</span><br><span class="line">                                                                    ; 虽然前面的步骤判断过一次了，</span><br><span class="line">                                                                    ; 前面是为了判断服务号是否越界，这里主要是找到合适的处理函数</span><br><span class="line">804df7a4 751a            jne     nt!KiFastCallEntry+0xcc (804df7c0) ; 若不等，</span><br><span class="line">                                                                    ; 跳转到处理查找第一个系统服务表的例程</span><br><span class="line">804df7a6 8b0d18f0dfff    mov     ecx,dword ptr ds:[0FFDFF018h]      ; 若要查找第二个系统服务表，</span><br><span class="line">                                                                    ; 从这里走，不作详细分析</span><br><span class="line">804df7ac 33db            xor     ebx,ebx</span><br><span class="line">804df7ae 0b99700f0000    or      ebx,dword ptr [ecx+0F70h]</span><br><span class="line">804df7b4 740a            je      nt!KiFastCallEntry+0xcc (804df7c0)</span><br><span class="line">804df7b6 52              push    edx</span><br><span class="line">804df7b7 50              push    eax</span><br><span class="line">804df7b8 ff1564b25580    call    dword ptr [nt!KeGdiFlushUserBatch (8055b264)]</span><br><span class="line">804df7be 58              pop     eax</span><br><span class="line">804df7bf 5a              pop     edx</span><br><span class="line">804df7c0 ff0538f6dfff    inc     dword ptr ds:[0FFDFF638h]  ; 如果查第一个表，会跳到这里来 [0xffdff638]</span><br><span class="line">                                                            ; KPRCB结构的0x518偏移处，存的是KeSystemCalls</span><br><span class="line">                                                            ; 这里自增1(具体用处到APC那块会讲到)</span><br><span class="line">804df7c6 8bf2            mov     esi,edx                    ; edx存着3环第一个参数的地址，赋给esi</span><br><span class="line">804df7c8 8b5f0c          mov     ebx,dword ptr [edi+0Ch]    ; ebx获取函数参数表地址</span><br><span class="line">804df7cb 33c9            xor     ecx,ecx                    ; 清空ecx，之前用来判断寻找哪个系统服务表</span><br><span class="line">804df7cd 8a0c18          mov     cl,byte ptr [eax+ebx]      ; cl获取函数参数个数</span><br><span class="line">804df7d0 8b3f            mov     edi,dword ptr [edi]        ; 另edi直接指向函数地址表首地址</span><br><span class="line">804df7d2 8b1c87          mov     ebx,dword ptr [edi+eax*4]  ; ebx获取到0环实现的内核函数</span><br><span class="line">804df7d5 2be1            sub     esp,ecx                    ; 提升堆栈，ecx里存的是参数个数的总字节</span><br><span class="line">804df7d7 c1e902          shr     ecx,2                      ; 相当于运算ecx/4，方便rep movsd，因为repmovsd是4字节运算</span><br><span class="line">804df7da 8bfc            mov     edi,esp                    ; rep movsd指令用，Copy的目的地</span><br><span class="line">804df7dc 3b35d40b5680    cmp     esi,dword ptr [nt!MmUserProbeAddress (80560bd4)] ; 检测三环参数地址范围是否越界</span><br><span class="line">804df7e2 0f83a8010000    jae     nt!KiSystemCallExit2+0x9f (804df990)             ; 若越界，进行异常处理</span><br><span class="line">804df7e8 f3a5            rep movs dword ptr es:[edi],dword ptr [esi]              ; 将参数复制到堆栈</span><br><span class="line">804df7ea ffd3            call    ebx                                              ; 调用0环函数！</span><br><span class="line">804df7ec 8be5            mov     esp,ebp</span><br><span class="line">804df7ee 8b0d24f1dfff    mov     ecx,dword ptr ds:[0FFDFF124h]</span><br><span class="line">804df7f4 8b553c          mov     edx,dword ptr [ebp+3Ch]</span><br><span class="line">804df7f7 899134010000    mov     dword ptr [ecx+134h],edx</span><br></pre></td></tr></table></figure>

<p>至此，这块KiFastCallEntry和KiSystemService最终都会执行的一段被我们称作SharedCode的代码段，就分析完了，</p>
<h2 id="SSDT"><a href="#SSDT" class="headerlink" title="SSDT"></a>SSDT</h2><p>前文提到了，我们可以通过fs找到KPCR，在通过KPCR找到KTHREAD，然后在KTHREAD+0xE0处找到系统服务表，这里再介绍另一种找到系统服务表的办法，通过SSDT。</p>
<h3 id="SSDT-amp-SSDT-Shadow"><a href="#SSDT-amp-SSDT-Shadow" class="headerlink" title="SSDT&amp;SSDT Shadow"></a>SSDT&amp;SSDT Shadow</h3><p>SSDT（System Services Descriptor Table）系统服务描述符表，在这个结构中包含4个成员，每个成员都是一个系统服务表的结构体，可以在Windbg中通过dd KeServiceDescriptorTable指令进行查看（在程序中可以直接声明全局变量KeServiceDescriptorTable，从而找到找到系统服务表。）：</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-06-16-29-11-5efc8a7397b23faf5aa4a06332fad1db-ssdt-d5b778.png"></p>
<p>我们可以看到第一个成员的ServiceTable，Count，ServiceLimit，ArgmentTable字段，Windows Xp只使用了2张表，所以第三个和第四个成员的位置是空的，此外，由于SSDT第二个成员是未导出的，所以第二个成员的位置也是空的。这里介绍一个新的指令，dd KeServiceDescriptorTableShadow，通过全局变量KeServiceDescriptorTableShadow可以查看两张完整的系统服务表。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-06-16-29-44-000ace61d0554aef0593375c1317347d-ssdts-51d1c4.png"></p>
<p>但是，全局变量<strong>KeServiceDescriptorTableShadow也是未导出的</strong>，在实际写程序时，不能通过直接访问win32k.sys导出的第二张系统服务表的函数地址，因为里面的函数地址都是无效的。原因是，win32k.sys导出的第二张系统服务表<strong>只有在当前进程访问GDI相关的API</strong>时，里面的<strong>函数地址表</strong>才会挂载到物理页上。如果进程没有用到GDI相关的API，那么第二张系统服务表里面的函数地址表就不会挂载到物理内存，那么里面的函数也无效。</p>
<h3 id="内核函数查找"><a href="#内核函数查找" class="headerlink" title="内核函数查找"></a>内核函数查找</h3><p>有了SSDT表，我们查找3环API对应的内核函数就很简单了，拿之前分析过的3环API函数ReadProcessMemory举例，在进入0环之前，给eax赋值了一个系统服务号0xba，那我们就用这个ba来查看这个这个函数在内核的实现。</p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-06-16-30-35-c1e2640985058e3a64ff6c4b5ab8b0f3-ssdtFind-a07738.png"></p>
<p>通过这张图，可以很清晰的看出来，ReadProcessMemory所实现的功能，在底层是由一个叫做NtReadVirtualMemory完成的。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>API函数的调用过程，从3环进入0环，再到找到对应的内核函数，这部分到这就差不多了，当然，真正的调用过程并没有到此结束，因为调用完0环的函数，总得返回3环呀！只是这部分需要用到APC的知识点，因此这里还不能完整实现。此外，在API函数调用这块，还有个小实验，在SSDT表中追加一个函数地址(NtReadVirtualMemory),自己编写API的3环部分调用这个新增的函数(注意：使用2-9-9-12分页，10-10-12会蓝屏)，就留到后面补上了</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>系统调用</tag>
        <tag>x86</tag>
        <tag>Windows内核</tag>
      </tags>
  </entry>
  <entry>
    <title>KPCR</title>
    <url>/2022/03/31/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/KPCR/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>进程在内核中对应结构体：EPROCESS</li>
<li>线程在内核中对应结构体：ETHREAD</li>
<li>CPU在内核中也有一个对应的结构体：<strong>KPCR（Processor Control Region）</strong></li>
</ul>
<p>KPCR结构我们已经很熟悉了，在API函数的调用过程中，多次使用到了KPCR，也简要介绍过一点。在保存现场之前有一个步骤就是将fs寄存器写入0x30，并根据GDT表，让fs寄存器指向KPCR。</p>
<h2 id="KPCR介绍"><a href="#KPCR介绍" class="headerlink" title="KPCR介绍"></a>KPCR介绍</h2><ol>
<li>当线程进入0环时，FS:[0]指向KPCR（3环时FS:[0] -&gt; TEB）</li>
<li>每个CPU都有一个KPCR结构体（一个核一个）</li>
<li>KPCR中存储了CPU本身要用的一些重要数据：GDT、IDT以及线程相关的一些信息。</li>
<li>在Windbg中执行指令：dt _KPCR 查看KPCR结构</li>
<li>结构体：</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-59-55-7df623e0800a85ae76c05f51824af3fa-image-20220814145955300-ce0651.png"></p>
<h2 id="KPCR成员"><a href="#KPCR成员" class="headerlink" title="KPCR成员"></a>KPCR成员</h2><h3 id="0x000-NtTib"><a href="#0x000-NtTib" class="headerlink" title="+0x000 NtTib"></a>+0x000 NtTib</h3><ul>
<li>成员名：NtTib</li>
<li>数据类型：_NT_TIB</li>
<li>说明：<strong>KPCR的第一个成员</strong>，存储部分关键信息（<strong>TEB的第一个成员也是这个结构</strong>）</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-15-01-42-3a13c534605d536df9e9dc3b0c7d3545-image-20220814150142546-8e4cf3.png"></p>
<h4 id="0x000-ExceptionList"><a href="#0x000-ExceptionList" class="headerlink" title="+0x000 ExceptionList"></a>+0x000 ExceptionList</h4><ul>
<li>成员名：ExceptionList</li>
<li>数据类型：Ptr32 _EXCEPTION_REGISTRATION_RECORD</li>
<li>说明：指向当前线程的异常链表（SEH），包含了当前线程的异常处理函数。<strong>Ring0（KPRC的ExceptionList）和Ring3（TEB的ExceptionList）的异常处理函数不同</strong></li>
</ul>
<h4 id="0x004-StackBase-x2F-0x008-StackLimit"><a href="#0x004-StackBase-x2F-0x008-StackLimit" class="headerlink" title="+0x004 StackBase&#x2F;+0x008 StackLimit"></a>+0x004 StackBase&#x2F;+0x008 StackLimit</h4><ul>
<li>成员名：StackBase&#x2F;StackLimit</li>
<li>数据类型：Ptr32 Void</li>
<li>说明：当前线程内核栈的基址和大小（<strong>KPCR中的是Ring0相关，TEB中就是Ring3相关</strong>）</li>
</ul>
<h4 id="0x018-Self"><a href="#0x018-Self" class="headerlink" title="+0x018 Self"></a>+0x018 Self</h4><ul>
<li>成员名：Self</li>
<li>数据类型：Ptr32 _NT_TIB</li>
<li>说明：指向自己（也就是指向_NT_TIB结构）这样设计的目的是为了查找方便。<strong>Ring0-&gt;KPCR，Ring3-&gt;TEB</strong></li>
</ul>
<h3 id="0x01c-SelfPcr"><a href="#0x01c-SelfPcr" class="headerlink" title="+0x01c SelfPcr"></a>+0x01c SelfPcr</h3><ul>
<li>成员名：SelfPcr</li>
<li>数据类型：Ptr32 _KPCR</li>
<li>说明：指向自己，方便寻址</li>
</ul>
<h3 id="0x020-Prcb"><a href="#0x020-Prcb" class="headerlink" title="+0x020 Prcb"></a>+0x020 Prcb</h3><ul>
<li>成员名：Prcb</li>
<li>数据类型：Ptr32 _KPRCB</li>
<li>说明：指向扩展结构体KPRCB</li>
</ul>
<h3 id="0x038-IDT"><a href="#0x038-IDT" class="headerlink" title="+0x038 IDT"></a>+0x038 IDT</h3><ul>
<li>成员名：IDT</li>
<li>数据类型：Ptr32 _KIDTENTRY</li>
<li>说明：指向IDT表首地址</li>
</ul>
<h3 id="0x03c-GDT"><a href="#0x03c-GDT" class="headerlink" title="+0x03c GDT"></a>+0x03c GDT</h3><ul>
<li>成员名：GDT</li>
<li>数据类型：Ptr32 _KGDTENTRY</li>
<li>说明：指向GDT表首地址</li>
</ul>
<h3 id="0x040-TSS"><a href="#0x040-TSS" class="headerlink" title="+0x040 TSS"></a>+0x040 TSS</h3><ul>
<li>成员名：TSS</li>
<li>数据类型：Ptr32 _KTSS</li>
<li>说明：指向TSS，每个CPU都有一个TSS</li>
</ul>
<h3 id="0x051-Number"><a href="#0x051-Number" class="headerlink" title="+0x051 Number"></a>+0x051 Number</h3><ul>
<li>成员名：Number</li>
<li>数据类型：UChar</li>
<li>说明：CPU编号</li>
</ul>
<h3 id="0x120-PrcbData"><a href="#0x120-PrcbData" class="headerlink" title="+0x120 PrcbData"></a>+0x120 PrcbData</h3><ul>
<li>成员名：PrcbData</li>
<li>数据类型：_KPRCB</li>
<li>说明：KPCR的扩展结构体</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-15-02-06-f343377d9ce197cc22a5850a87543569-kprcb-ae4754.png"></p>
<h2 id="KPRCB结构体"><a href="#KPRCB结构体" class="headerlink" title="KPRCB结构体"></a>KPRCB结构体</h2><p>KPRCB（Kernel Processor Control Block）是KPCR的扩展结构体</p>
<h4 id="0x004-CurrentThread"><a href="#0x004-CurrentThread" class="headerlink" title="+0x004 CurrentThread"></a>+0x004 CurrentThread</h4><p>成员名：CurrentThread</p>
<p>数据类型：Ptr32 _KTHREAD</p>
<p>说明：指向当前线程的KTHREAD</p>
<h4 id="0x008-NextThread"><a href="#0x008-NextThread" class="headerlink" title="+0x008 NextThread"></a>+0x008 NextThread</h4><p>成员名：CurrentThread</p>
<p>数据类型：Ptr32 _KTHREAD</p>
<p>说明：指向下一个要执行线程的KTHREAD</p>
<h4 id="0x00c-IdleThread"><a href="#0x00c-IdleThread" class="headerlink" title="+0x00c IdleThread"></a>+0x00c IdleThread</h4><p>成员名：IdleThread</p>
<p>数据类型：Ptr32 _KTHREAD</p>
<p>说明：指向空闲线程的KTHREAD</p>
<h4 id="0x88c-QuantumEnd"><a href="#0x88c-QuantumEnd" class="headerlink" title="+0x88c QuantumEnd"></a>+0x88c QuantumEnd</h4><p>成员名：QuantumEnd</p>
<p>数据类型：Uint4B</p>
<p>说明：CPU时间片标志</p>
<h2 id="关系梳理"><a href="#关系梳理" class="headerlink" title="关系梳理"></a>关系梳理</h2><p>在简单了解完进程结构体（EPROCESS）、线程结构体（ETHREAD）、CPU结构体（KPCR）以后，来梳理一下它们之间的关系。</p>
<h3 id="已知进程"><a href="#已知进程" class="headerlink" title="已知进程"></a>已知进程</h3><p>遍历进程：PsActiveProcessHead -&gt; ActiveProcessLinks(EPROCESS+0x88)……</p>
<p>遍历线程：PsActiveProcessHead -&gt; ActiveProcessLinks(EPROCESS+0x88) -&gt; ThreadListHead(KPROCESS+0x50 &#x2F; EPROCESS+0x190) -&gt; ThreadListEntry(KTHREAD+0x1b0 &#x2F; ETHREAD+0x22c)……</p>
<h3 id="已知线程"><a href="#已知线程" class="headerlink" title="已知线程"></a>已知线程</h3><p>遍历进程：ETHREAD+0x220 -&gt; EPROCESS -&gt; ActiveProcessLinks(EPROCESS+0x88)……</p>
<p>遍历线程：ETHREAD+0x22c &#x2F; ETHREAD+0x1b0 -&gt; ThreadListEntry……</p>
<h3 id="已知KPCR"><a href="#已知KPCR" class="headerlink" title="已知KPCR"></a>已知KPCR</h3><p>遍历进程：进入0环后 -&gt; fs:[0] -&gt; KPCR -&gt; PrcbData(KPCR+0x120) -&gt; CurrentThread(KPRCB+0x4) -&gt; EPROCESS(ETHREAD+0x220) -&gt; ActiveProcessLinks(EPROCESS+0x88)……</p>
<p>遍历线程：进入0环后 -&gt; fs:[0] -&gt; KPCR -&gt; PrcbData(KPCR+0x120) -&gt; CurrentThread(KPRCB+0x4) -&gt; ETHREAD+0x22c &#x2F; ETHREAD+0x1b0 -&gt; ThreadListEntry……</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟线程切换</title>
    <url>/2022/04/02/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E6%A8%A1%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们知道<strong>CPU执行和调度的单位是线程</strong>，在有了线程结构体（ETHREAD）以及等待链表，调度链表的概念后，这一篇简单介绍一下线程切换，通过分析<strong>模拟线程切换</strong>的代码（源于滴水编程达人海东老师编写）来了解线程切换的过程及原理。</p>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXGMTHREAD 0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREADSTACKSIZE 0x80000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_CREATE 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_READY 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_RUNING 0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_SLEEP 0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_EXIT 0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _SELF abcd1234</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>					//定义线程结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span>* name;				<span class="comment">//线程名</span></span><br><span class="line">	<span class="type">int</span> Flags;				<span class="comment">//定义状态：Ready/Sleep/Running</span></span><br><span class="line">	<span class="type">int</span> SleepMillisecondDot;		<span class="comment">//休眠时间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* InitialStack;			<span class="comment">//栈底</span></span><br><span class="line">	<span class="type">void</span>* StackLimit;			<span class="comment">//栈限长</span></span><br><span class="line">	<span class="type">void</span>* KernelStack;			<span class="comment">//栈顶</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *lpParameter;			<span class="comment">//线程函数参数</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter);	<span class="comment">//线程函数</span></span><br><span class="line">&#125;GMThread_t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  CurrentThreadIndex = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span>* WindowsStackLimit = <span class="literal">NULL</span>;</span><br><span class="line">GMThread_t GMThreadList[MAXGMTHREAD] = &#123;<span class="literal">NULL</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>** Stackpp, <span class="type">unsigned</span> <span class="type">int</span> v)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">RegisterGMThread</span><span class="params">(<span class="type">char</span>* name, <span class="type">void</span> (*func)(<span class="type">void</span>* lpParameter), <span class="type">void</span>* lpParameter)</span>;	</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGMThread</span><span class="params">(GMThread_t* GMThreadp, <span class="type">char</span>* name, <span class="type">void</span> (*func)(<span class="type">void</span>* lpParameter), <span class="type">void</span> * lpParameter)</span>;	</span><br><span class="line"><span class="type">void</span> <span class="title function_">GMThreadStartup</span><span class="params">(GMThread_t* GMThreadp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Scheduling</span><span class="params">(<span class="type">void</span>)</span>;				</span><br><span class="line"><span class="type">void</span> <span class="title function_">SwitchContext</span><span class="params">(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">GMSleep</span><span class="params">(<span class="type">int</span> Milliseconds)</span>;			</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread1</span><span class="params">(<span class="type">void</span>* lpParameter)</span>;		</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread2</span><span class="params">(<span class="type">void</span>* lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread3</span><span class="params">(<span class="type">void</span>* lpParameter)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread4</span><span class="params">(<span class="type">void</span>* lpParameter)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread1&quot;</span>, Thread1, <span class="literal">NULL</span>);		</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread2&quot;</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread3&quot;</span>, Thread3, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread4&quot;</span>, Thread4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">20</span>);	</span><br><span class="line">		Scheduling();	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中压入值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>** Stackpp, <span class="type">unsigned</span> <span class="type">int</span> v)</span>	</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ESP 减去一个单位（4个字节）</span></span><br><span class="line">	*Stackpp -= <span class="number">1</span>;		</span><br><span class="line">	**Stackpp = v;		</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将一个函数注册为单独线程执行</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">RegisterGMThread</span><span class="params">(<span class="type">char</span>* name, <span class="type">void</span> (*func)(<span class="type">void</span>* lpParameter), <span class="type">void</span>* lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; GMThreadList[i].name; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(GMThreadList[i].name, name))	</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	InitGMThread(&amp;GMThreadList[i], name, func, lpParameter);	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化线程的信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGMThread</span><span class="params">(GMThread_t* GMThreadp, <span class="type">char</span>* name, <span class="type">void</span> (*func)(<span class="type">void</span>* lpParameter), <span class="type">void</span> * lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* StackPages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>* StackDWORDParam;</span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_CREATE;		</span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;name = name;				</span><br><span class="line">	GMThreadp-&gt;func = func;</span><br><span class="line">	GMThreadp-&gt;lpParameter = lpParameter;</span><br><span class="line"></span><br><span class="line">	StackPages = (<span class="type">unsigned</span> <span class="type">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE);	</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">memset</span>(StackPages, <span class="literal">NULL</span>, GMTHREADSTACKSIZE);	</span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;InitialStack = StackPages + GMTHREADSTACKSIZE;	</span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;StackLimit = StackPages;		</span><br><span class="line"></span><br><span class="line">	StackDWORDParam = (<span class="type">unsigned</span> <span class="type">int</span>*)GMThreadp-&gt;InitialStack;	</span><br><span class="line"></span><br><span class="line">	PushStack(&amp;StackDWORDParam, (<span class="type">unsigned</span> <span class="type">int</span>)GMThreadp);		</span><br><span class="line">	PushStack(&amp;StackDWORDParam, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">9</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, (<span class="type">unsigned</span> <span class="type">int</span>)GMThreadStartup);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">5</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">7</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">6</span>);</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">3</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">2</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">1</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">0</span>);	</span><br><span class="line">	</span><br><span class="line">	GMThreadp-&gt;KernelStack = StackDWORDParam;	</span><br><span class="line"></span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_READY;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动线程的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">GMThreadStartup</span><span class="params">(GMThread_t* GMThreadp)</span></span><br><span class="line">&#123;</span><br><span class="line">	GMThreadp-&gt;func(GMThreadp-&gt;lpParameter);	</span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_EXIT;	</span><br><span class="line">	</span><br><span class="line">	Scheduling();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程调度函数，这个函数使得当前线程让出CPU，从队列里重新选择一个线程执行</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Scheduling</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> TickCount;</span><br><span class="line">	GMThread_t* SrcGMThreadp;	</span><br><span class="line">	GMThread_t* DstGMThreadp;	</span><br><span class="line">    </span><br><span class="line">	TickCount = GetTickCount();	</span><br><span class="line"></span><br><span class="line">	SrcGMThreadp = &amp;GMThreadList[CurrentThreadIndex];	</span><br><span class="line">	DstGMThreadp = &amp;GMThreadList[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; GMThreadList[i].name; i++)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GMThreadList[i].Flags &amp; GMTHREAD_SLEEP)		</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (TickCount &gt; GMThreadList[i].SleepMillisecondDot)	</span><br><span class="line">			&#123;</span><br><span class="line">				GMThreadList[i].Flags = GMTHREAD_READY;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (GMThreadList[i].Flags &amp; GMTHREAD_READY)	</span><br><span class="line">		&#123;</span><br><span class="line">			DstGMThreadp = &amp;GMThreadList[i];	</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	CurrentThreadIndex = DstGMThreadp - GMThreadList;	</span><br><span class="line">	SwitchContext(SrcGMThreadp, DstGMThreadp);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//切换线程</span></span><br><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">SwitchContext</span><span class="params">(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp)</span>	</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push ebp</span><br><span class="line">		mov ebp, esp</span><br><span class="line"></span><br><span class="line">		push edi	</span><br><span class="line">		push esi</span><br><span class="line">		push ebx</span><br><span class="line">		push ecx</span><br><span class="line">		push edx</span><br><span class="line">		push eax	</span><br><span class="line">		</span><br><span class="line">		mov esi, SrcGMThreadp	</span><br><span class="line">		mov edi, DstGMThreadp</span><br><span class="line"></span><br><span class="line">		mov [esi + GMThread_t.KernelStack], esp	</span><br><span class="line">		<span class="comment">//经典线程切换的实现，本质就是切换堆栈</span></span><br><span class="line">		mov esp, [edi + GMThread_t.KernelStack]	</span><br><span class="line"></span><br><span class="line">		pop eax		</span><br><span class="line">		pop edx</span><br><span class="line">		pop ecx</span><br><span class="line">		pop ebx</span><br><span class="line">		pop esi</span><br><span class="line">		pop edi</span><br><span class="line">		</span><br><span class="line">		pop ebp</span><br><span class="line">		ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GMSleep</span><span class="params">(<span class="type">int</span> Milliseconds)</span></span><br><span class="line">&#123;</span><br><span class="line">	GMThread_t* GMThreadp;</span><br><span class="line">	GMThreadp = &amp;GMThreadList[CurrentThreadIndex];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (GMThreadp-&gt;Flags != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		GMThreadp-&gt;SleepMillisecondDot = GetTickCount() + Milliseconds;</span><br><span class="line">		GMThreadp-&gt;Flags = GMTHREAD_SLEEP;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Scheduling();</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread1</span><span class="params">(<span class="type">void</span>* lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread1\n&quot;</span>);</span><br><span class="line">		GMSleep(<span class="number">500</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread2</span><span class="params">(<span class="type">void</span>* lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread2\n&quot;</span>);</span><br><span class="line">		GMSleep(<span class="number">200</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread3</span><span class="params">(<span class="type">void</span>* lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread3\n&quot;</span>);</span><br><span class="line">		GMSleep(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Thread4</span><span class="params">(<span class="type">void</span>* lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Thread4\n&quot;</span>);</span><br><span class="line">		GMSleep(<span class="number">1000</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>上述代码较长，且每行长短不一，故注释较乱，这里进行一些简要分析</p>
<h3 id="模拟线程结构体"><a href="#模拟线程结构体" class="headerlink" title="模拟线程结构体"></a>模拟线程结构体</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>					//定义线程结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">char</span>* name;</span><br><span class="line">	<span class="type">int</span> Flags;				<span class="comment">//定义状态：Ready/Sleep/Running</span></span><br><span class="line">	<span class="type">int</span> SleepMillisecondDot;		<span class="comment">//线程等待时间</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>* InitialStack;			<span class="comment">//栈底</span></span><br><span class="line">	<span class="type">void</span>* StackLimit;			<span class="comment">//栈限长</span></span><br><span class="line">	<span class="type">void</span>* KernelStack;			<span class="comment">//栈顶</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span> *lpParameter;			<span class="comment">//线程函数参数</span></span><br><span class="line">	<span class="type">void</span> (*func)(<span class="type">void</span> *lpParameter);	<span class="comment">//线程函数</span></span><br><span class="line">&#125; GMThread_t;</span><br></pre></td></tr></table></figure>

<p>这是这份代码里<strong>最重要的结构体</strong>，它定义了我们模拟线程的结构，实际上，就是一个<strong>乞丐版的ETHREAD</strong>，只是很多ETHREAD中的成员我们用不到，就省去了，但仍然可以模拟线程切换的过程，这也算是个五脏俱全的线程结构体，我们来看看都有哪些成员吧：</p>
<ul>
<li>name：很好理解，线程的名字，用于标记线程</li>
<li>Flags：线程的状态，我们可以根据线程的状态将它放入等待链表或者让它执行</li>
<li>SleepMillisecondDot：线程的休眠时间。</li>
<li>InitialStack&#x2F;StackLimit&#x2F;KernelStack：可以说这是线程切换<strong>最重要</strong>的3个成员，每个<strong>线程执行时都需要有自己的堆栈</strong>，而具体该如何分配堆栈就要依靠这3个值，<strong>InitialStack提供了线程的栈底</strong>(ebp)；<strong>KernelStack提供了栈顶(<strong>esp)；</strong>StackLimit决定了栈的边界</strong>，可以这样理解，该线程的堆栈只能位于[ebp, ebp+StakLimit]的范围内，一旦超出这个范围，就会发生错误</li>
<li>lpParameter&#x2F;func：分别是线程函数参数和线程函数，可以执行特定函数显示具体线程</li>
</ul>
<h3 id="全局变量和宏"><a href="#全局变量和宏" class="headerlink" title="全局变量和宏"></a>全局变量和宏</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXGMTHREAD 0x100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREADSTACKSIZE 0x80000</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_CREATE 0x1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_READY 0x2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_RUNING 0x4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_SLEEP 0x8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GMTHREAD_EXIT 0x100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>  CurrentThreadIndex = <span class="number">0</span>;</span><br><span class="line">GMThread_t GMThreadList[MAXGMTHREAD] = &#123;<span class="literal">NULL</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>MAXGMTHREAD：指明线程最多能有多少个</li>
<li>GMTHREADSTACKSIZE：这里说的是线程分配的堆栈能有多大，<strong>每个线程都拥有自己的堆栈</strong>，但是不能无限大，大小的限制由KTHREAD结构里的KernelStack决定</li>
<li>GMTHREAD_CREATE&#x2F;READAY&#x2F;RUNING&#x2F;SLEEP&#x2F;EXIT：均为<strong>线程的状态</strong></li>
<li>CurrentThreadIndex：可以理解为Index，用于遍历，这里作为全局变量进行声明。</li>
<li>GMThreadList：这里的类型是GMThread_t，说明这是<strong>模拟线程结构体链表</strong>，在KTHREAD结构体中，使用了WaitListEntry和SwapListEntry，根据线程的状态，将线程放入不同的链表中。这里，海东老师只用了一个数组，用来存放线程，其中<strong>下标0的位置，存放主函数的线程</strong>，其余位置存放不同状态的线程。</li>
</ul>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread1&quot;</span>, Thread1, <span class="literal">NULL</span>);		<span class="comment">//注册线程1， 2， 3，4</span></span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread2&quot;</span>, Thread2, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread3&quot;</span>, Thread3, <span class="literal">NULL</span>);</span><br><span class="line">	RegisterGMThread(<span class="string">&quot;Thread4&quot;</span>, Thread4, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Sleep(<span class="number">20</span>);	<span class="comment">//短暂等待</span></span><br><span class="line">		Scheduling();	<span class="comment">//线程调度</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>程序是从主函数开始执行的，我们按照函数执行的顺序进行分析</p>
<ul>
<li>RegisterGMThread()：将一个<strong>函数注册为</strong>单独的<strong>线程</strong>来执行</li>
<li>Scheduling()：调度函数，使得当前线程让出CPU，并从队列中（GMThreadList）重新选择一个线程执行</li>
</ul>
<h3 id="线程注册函数"><a href="#线程注册函数" class="headerlink" title="线程注册函数"></a>线程注册函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">RegisterGMThread</span><span class="params">(<span class="type">char</span>* name, <span class="type">void</span> (*func)(<span class="type">void</span>* lpParameter), <span class="type">void</span>* lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; GMThreadList[i].name; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(GMThreadList[i].name, name))	</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	InitGMThread(&amp;GMThreadList[i], name, func, lpParameter);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> i；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>参数：线程名，线程函数，线程函数参数</li>
<li>前面提到了，下标0的位置，存放着是main线程，所以这里从下标1开始写入，对数组中未初始化的线程通过初始化函数InitiGMThread()进行初始化</li>
</ul>
<h3 id="压栈函数"><a href="#压栈函数" class="headerlink" title="压栈函数"></a>压栈函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PushStack</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>** Stackpp, <span class="type">unsigned</span> <span class="type">int</span> v)</span>	</span><br><span class="line">&#123;</span><br><span class="line">	*Stackpp -= <span class="number">1</span>;	<span class="comment">//栈减一个int长度，就是4字节</span></span><br><span class="line">	**Stackpp = v;	<span class="comment">//并在这个位置存值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在介绍线程初始化函数前，先看一下这个压栈函数，这个函数非常简单，传了2个参数，一个指针，一个数。压栈函数的作用就是，指针-1（因为是*Stackpp，所以减的是int类型，即4字节），并在压栈后的地址存这个数，文字叙述可能不好理解，我们把这个转换一下就好理解了，其实就是代码实现的一个简单压栈操作</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_asm &#123;</span><br><span class="line">	sub esp, 4</span><br><span class="line">	mov eax, v</span><br><span class="line">	mov esp, eax</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">or </span><br><span class="line"></span><br><span class="line">_asm &#123;</span><br><span class="line">	push v</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="线程初始化函数"><a href="#线程初始化函数" class="headerlink" title="线程初始化函数"></a>线程初始化函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitGMThread</span><span class="params">(GMThread_t* GMThreadp, <span class="type">char</span>* name, <span class="type">void</span> (*func)(<span class="type">void</span>* lpParameter), <span class="type">void</span> * lpParameter)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>* StackPages;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>* StackDWORDParam;</span><br><span class="line">	<span class="comment">//初始化线程结构体</span></span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_CREATE;		</span><br><span class="line">	GMThreadp-&gt;name = name;		</span><br><span class="line">	GMThreadp-&gt;func = func;</span><br><span class="line">	GMThreadp-&gt;lpParameter = lpParameter;</span><br><span class="line">	</span><br><span class="line">    	<span class="comment">//分配80个连在一起的可以直接用的物理页</span></span><br><span class="line">	StackPages = (<span class="type">unsigned</span> <span class="type">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, GMTHREADSTACKSIZE, MEM_COMMIT, PAGE_READWRITE);	</span><br><span class="line">    	<span class="comment">//将分配的内存先都清0</span></span><br><span class="line">	<span class="built_in">memset</span>(StackPages, <span class="literal">NULL</span>, GMTHREADSTACKSIZE);	</span><br><span class="line">    	<span class="comment">//设置栈底ebp</span></span><br><span class="line">	GMThreadp-&gt;InitialStack = StackPages + GMTHREADSTACKSIZE;	</span><br><span class="line">	<span class="comment">//设置栈的最大上限</span></span><br><span class="line">	GMThreadp-&gt;StackLimit = StackPages;		</span><br><span class="line">	<span class="comment">//将ebp赋值StackDWORDParam</span></span><br><span class="line">	StackDWORDParam = (<span class="type">unsigned</span> <span class="type">int</span>*)GMThreadp-&gt;InitialStack;	</span><br><span class="line"></span><br><span class="line">	PushStack(&amp;StackDWORDParam, (<span class="type">unsigned</span> <span class="type">int</span>)GMThreadp);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, (<span class="type">unsigned</span> <span class="type">int</span>)<span class="number">9</span>);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, (<span class="type">unsigned</span> <span class="type">int</span>)GMThreadStartup);	</span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">5</span>);	<span class="comment">//ebp</span></span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">7</span>);	<span class="comment">//edi</span></span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">6</span>);	<span class="comment">//esi</span></span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">3</span>);	<span class="comment">//ebx</span></span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">2</span>);	<span class="comment">//ecx</span></span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">1</span>);	<span class="comment">//edx</span></span><br><span class="line">	PushStack(&amp;StackDWORDParam, <span class="number">0</span>);	<span class="comment">//eax</span></span><br><span class="line">	</span><br><span class="line">    	<span class="comment">//令KernelStack指向栈顶esp</span></span><br><span class="line">	GMThreadp-&gt;KernelStack = StackDWORDParam;	</span><br><span class="line">    	<span class="comment">//修改线程状态Create-&gt;Ready</span></span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_READY;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程初始化：线程初始化总共分为2步，一个是对<strong>线程结构体的初始化</strong>，另一个是对线程所在<strong>堆栈的初始化</strong></p>
<ul>
<li><p>线程结构体初始化：对代码中定义的<strong>简约版线程结构体</strong>GMThread_t中的部分成员进行初始化，包括线程状态，线程名，线程函数及参数。</p>
</li>
<li><p>线程堆栈初始化：我们知道，每一个线程，都得有属于自己堆栈，总不能跑到别人的堆栈上执行吧，这样就乱套了因此线程得拥有自己的堆栈。来看一下模拟线程切换的代码中是如何实现的：</p>
<ul>
<li><p>第一步用VirutalAlloc函数申请一块连续的内存（分配类型使用MEM_COMMIT）</p>
</li>
<li><p>初始化这块内存（置零）</p>
</li>
<li><p>设置栈底，栈顶，边界</p>
<p>，这部分非常关键，也是设置线程堆栈的核心步骤。在KTHREAD结构中，有InitialStack&#x2F;StackLimit&#x2F;KernelStack决定线程的堆栈相关参数。本次的模拟程序里也定义了这三个成员，我们来看下他们是如何运作的。</p>
<ul>
<li>InitialStack：这个成员相当于栈底，也就是ebp，在Windows中，堆栈的由高地址向低地址延申的，所以这里设置ebp的值为<strong>申请内存的首地址+堆栈限制大小</strong></li>
<li>StackLimit：这个成员定义栈的边界，栈的范围应在[InitialStack - StackLimit, InitialStack]内，这里令其<strong>等于申请内存的首地址</strong>，因为栈由高地址向下延申，因此栈的边界会位于此处</li>
<li>KernelStack：这个成员指向栈顶，相当于esp。这里的几步非常关键，按照顺序<strong>依次push了线程结构体</strong>，一个数，**一个执行线程的函数GMThreadStartup()**，接着又是一堆数，最后，将栈顶（通过压栈函数减了很多次），赋值给了KernelStack</li>
</ul>
</li>
</ul>
<p>以上就是线程初始化最关键的部分，可以参考这张图 </p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-14-22-e6b81eca38da0a9bfa820d309ba836cb-threadStack-f0c3df.png"></p>
</li>
</ul>
<h3 id="线程调度函数"><a href="#线程调度函数" class="headerlink" title="线程调度函数"></a>线程调度函数</h3><p>回到主函数，<strong>线程注册函数执行完</strong>后（线程初始化函数中的线程调用函数并未执行，只是被压栈了，所以稍后分析），就到了<strong>线程调度函数</strong>，一起来看一下线程调度函数都做了些什么吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Scheduling</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="type">int</span> TickCount;</span><br><span class="line">    </span><br><span class="line">	GMThread_t* SrcGMThreadp;</span><br><span class="line">	GMThread_t* DstGMThreadp;	</span><br><span class="line">    </span><br><span class="line">	TickCount = GetTickCount();	</span><br><span class="line">	<span class="comment">//指向正在执行的线程</span></span><br><span class="line">	SrcGMThreadp = &amp;GMThreadList[CurrentThreadIndex];	</span><br><span class="line">    	<span class="comment">//指向准备执行的线程</span></span><br><span class="line">	DstGMThreadp = &amp;GMThreadList[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//遍历线程数组，找到第一个状态为就绪的线程</span></span><br><span class="line">	<span class="keyword">for</span> (i=<span class="number">1</span>; GMThreadList[i].name; i++)	</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (GMThreadList[i].Flags &amp; GMTHREAD_SLEEP)		</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (TickCount &gt; GMThreadList[i].SleepMillisecondDot)	</span><br><span class="line">			&#123;</span><br><span class="line">				GMThreadList[i].Flags = GMTHREAD_READY;	</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (GMThreadList[i].Flags &amp; GMTHREAD_READY)	</span><br><span class="line">		&#123;</span><br><span class="line">			DstGMThreadp = &amp;GMThreadList[i];	</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//得到即将执行的线程下标</span></span><br><span class="line">	CurrentThreadIndex = DstGMThreadp - GMThreadList;	</span><br><span class="line">    	<span class="comment">//线程切换</span></span><br><span class="line">	SwitchContext(SrcGMThreadp, DstGMThreadp);	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程调度函数不是很复杂，比较好理解，这里简要概括下：</p>
<ol>
<li>开头部分定义了两个线程结构体指针：SrcGMThreadp，DstGMThreadp</li>
<li>SrcGMThreadp指向正在运行的线程，DstGMThreadp<strong>遍历线程数组</strong>，<strong>找到第一个状态为就绪的线程</strong>并指向它</li>
<li>保存DstGMThreadp指向的线程在数组中的下标（下次调度时好知道，正在运行的线程位于什么位置）</li>
<li>通过<strong>SwitchContext将这两个线程进行切换</strong></li>
</ol>
<h3 id="线程切换函数"><a href="#线程切换函数" class="headerlink" title="线程切换函数"></a>线程切换函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__declspec(naked) <span class="type">void</span> <span class="title function_">SwitchContext</span><span class="params">(GMThread_t* SrcGMThreadp, GMThread_t* DstGMThreadp	</span></span><br><span class="line"><span class="params">&#123;</span></span><br><span class="line"><span class="params">	__asm</span></span><br><span class="line"><span class="params">	&#123;</span></span><br><span class="line"><span class="params">		push ebp</span></span><br><span class="line"><span class="params">		mov ebp, esp</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">		push edi	</span></span><br><span class="line"><span class="params">		push esi</span></span><br><span class="line"><span class="params">		push ebx</span></span><br><span class="line"><span class="params">		push ecx</span></span><br><span class="line"><span class="params">		push edx</span></span><br><span class="line"><span class="params">		push eax	</span></span><br><span class="line"><span class="params">		</span></span><br><span class="line"><span class="params">		mov esi, SrcGMThreadp	</span></span><br><span class="line"><span class="params">		mov edi, DstGMThreadp</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">		mov [esi + GMThread_t.KernelStack], esp	</span></span><br><span class="line"><span class="params">		<span class="comment">//经典线程切换!!!本质是堆栈的切换！</span></span></span><br><span class="line"><span class="params">		mov esp, [edi + GMThread_t.KernelStack]	</span></span><br><span class="line"><span class="params"></span></span><br><span class="line"><span class="params">		pop eax		</span></span><br><span class="line"><span class="params">		pop edx</span></span><br><span class="line"><span class="params">		pop ecx</span></span><br><span class="line"><span class="params">		pop ebx</span></span><br><span class="line"><span class="params">		pop esi</span></span><br><span class="line"><span class="params">		pop edi</span></span><br><span class="line"><span class="params">		</span></span><br><span class="line"><span class="params">		pop ebp</span></span><br><span class="line"><span class="params">		ret</span></span><br><span class="line"><span class="params">	&#125;</span></span><br><span class="line"><span class="params">&#125;</span></span><br></pre></td></tr></table></figure>

<p>这是本篇<strong>最高能</strong>的地方了，我们来详细分析一下，这个看上去简单的代码是如何实现线程切换的。我们来一步步的看：</p>
<ol>
<li><p>最开始，一堆push，非常好理解，就是保存寄存器的值嘛！</p>
</li>
<li><p>接下来，两个mov操作，将指向<strong>正在运行的线程结构体的指针赋给了esi</strong>，将指向<strong>准备运行的线程结构体的指针赋给了edi</strong></p>
</li>
<li><p>然后，<strong>线程切换最经典的操作</strong>来了！将当前esp，赋值给esi指向线程的KernelStack；同时，将edi指向线程的KernelStack赋给esp。我们知道<strong>KernelStack存的是线程自己堆栈的esp</strong>，程序中的esp，是当前CPU执行的时的堆栈，而这个操作就是把当前堆栈保存到即将<strong>被切换</strong>的线程的KernleStack中，同时，让<strong>CPU执行所在的堆栈变成切换后的线程的KernelStack</strong>，说简单点，这个操作就是一次<strong>堆栈的切换</strong>！<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-17-19-27-d12d774bba74194a0d5c849eb2cbfe2f-stackSwitch-76de7c.png"></p>
</li>
<li><p>还没完！后面还有一堆pop，你以为就没用了嘛？仔细想想，<strong>堆栈已经发生了切换</strong>了！所以<strong>即将pop的那些值已经不是上面push进去的值</strong>了！那pop出来的值又是什么值呢？<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-14-37-7b72739e9505765bd454bbf51c58ddc6-popStack-c51626.png"></p>
</li>
</ol>
<p>没错，就是在线程初始化函数中Push进去的那些值，一直到pop ebp都比较好理解</p>
<ol start="5">
<li>接下来，一个ret，又是一个<strong>精髓指令</strong>，通过这个ret指令，刚好调用一个用来执行线程的函数GMThreadStartup()，这个函数会让线程<strong>调用自己的线程函数</strong>。这里有一个细节，就是这个函数传递了一个线程结构体指针，但是在裸函数中，<strong>ret语句执行完就跳转到GMThreadStartup()函数的开始</strong>处执行，那么它又是如何获取参数的呢？我们来查看一下反汇编</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-17-16-00-fb50c663afb657915e256bd8a2eea1ad-threadStartup-a814ba.png"></p>
<p>根据这个函数的反汇编可以发现，它是<strong>通过[ebp+8]来获取参数</strong>的，而这个位置，刚好就是在初始化函数中，第一个push进去的线程结构体，紧接着<strong>push了一个9，仅仅是用来占位</strong>，从而<strong>使得[ebp+8]刚好可以指向线程结构体</strong>，从而获取参数，u1s1，这里细节妙不可言</p>
<p><strong>这里贴一张笔记，做的非常好，结合着看更易看懂代码</strong></p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-17-14-19-bdab960901653f2d3efa6a0962d2507b-zjj-2d7aab.png"></p>
<h3 id="执行线程函数"><a href="#执行线程函数" class="headerlink" title="执行线程函数"></a>执行线程函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void GMThreadStartup(GMThread_t* GMThreadp)</span><br><span class="line">&#123;</span><br><span class="line">	GMThreadp-&gt;func(GMThreadp-&gt;lpParameter);	</span><br><span class="line">	GMThreadp-&gt;Flags = GMTHREAD_EXIT;</span><br><span class="line">	//线程切换</span><br><span class="line">	Scheduling();</span><br><span class="line">	</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数，在上面刚讲过，主要就是最后，会再执行一次线程调度函数，实现下一次的线程切换，说明了一点，<strong>线程是主动切换的，主动让出CPU</strong></p>
<h3 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><p>最后，来看一下程序运行时的样子，就是在不断的线程切换 </p>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-17-13-38-e3de73b56b670dbc9b324081924220f9-running-6bcf71.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，程序主要部分就基本分析完毕，真的是非常巧妙的代码，海东老师太厉害了！这里对模拟线程切换做一个总结：</p>
<ul>
<li><strong>线程不是被动切换的，而是主动让出CPU</strong></li>
<li><strong>线程切换并没有使用TSS来保持寄存器，而是使用堆栈。</strong></li>
<li><strong>线程切换的过程就是切换堆栈的过程</strong></li>
</ul>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>等待链表&amp;调度链表</title>
    <url>/2022/04/01/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8&amp;%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前面介绍进程结构体时，进行了断链实验，程序可以正常运行，原因是<strong>CPU执行与调度的单位是线程</strong>，因此进程的断链并不影响程序的正常执行。对线程的断链也是一样的，断链后虽然可以隐藏断掉的线程，但同样不影响程序的执行。这说明，CPU调度时根本没有用到ThreadListEntry这个链表。接下来介绍两个与调度相关的链表：等待链表&amp;调度链表</p>
<h2 id="33个链表"><a href="#33个链表" class="headerlink" title="33个链表"></a>33个链表</h2><ul>
<li>线程有3种状态：就绪、等待、运行</li>
<li>正在运行中的线程存储在KPCR中，就绪和等待的线程全在另外的33个链表中。包括1个等待链表，32个就绪链表</li>
<li>这些链表都使用了_KTHREAD+0x060这个位置（如果是Win7的话，位于KTHREAD+0x074的位置），也就是说，线程在某一时刻，只能属于其中一个链表内</li>
</ul>
<h2 id="等待链表"><a href="#等待链表" class="headerlink" title="等待链表"></a>等待链表</h2><ul>
<li>查询指令：dd KiWaitListHead</li>
<li>说明：<ul>
<li>等待链表是一个<strong>双向链表</strong></li>
<li>当线程调用了Sleep()或者WaitForSingleObject()等函数时，就挂到这个链表</li>
</ul>
</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-16-54-32-dd25df6ec68b29bd85f9229e7d3ec361-waitListHead-5e91f0.png"></p>
<ul>
<li>关系梳理：KiWaitListHead -&gt; WaitListEntry(KTHREAD+0x60) -&gt; ThreadProcess(ETHREAD+0x220) -&gt; EPROCESS</li>
</ul>
<h2 id="调度链表"><a href="#调度链表" class="headerlink" title="调度链表"></a>调度链表</h2><ul>
<li>查询指令：dd KiDispatcherReadyListHead L70</li>
<li>说明：<ul>
<li>调度链表<strong>共32个双向链表</strong></li>
<li>有32个调度链表的原因是，<strong>运行中的线程是有线程优先级</strong>，根据下标表示线程优先级别（0~31）</li>
<li><strong>32位系统</strong>中，<strong>调度链表有32个</strong>（一组），64位系统则有64个（一组）</li>
<li>普通操作系统，只有一组调度链表，<strong>服务器版本系统</strong>中，<strong>调度链表的数量等于CPU的数量</strong>，但<strong>等待链表只有一个</strong></li>
</ul>
</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-16-55-18-ef6ab79751d89ee0b7f951560d89ea16-readyListHead-bbce35.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><strong>正在运行的线程位于KPCR</strong>中</li>
<li><strong>准备运行的线程</strong>根据线程优先级的不同，<strong>分布在32个调度链表中</strong>； KiDispatcherReadyListHead是个数组，存储了32个链表头</li>
<li><strong>等待状态的线程存储在等待链表</strong>里，KiWaitListHead存储了链表头</li>
<li>这些圈均挂在<strong>KTHREAD+0x060</strong>的位置（XP系统）</li>
</ol>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程结构体</title>
    <url>/2022/03/30/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows中每个进程会包含一个或多个线程，每个线程在0环都有一个对应的结构体：ETHREAD，这个结构体包含了线程所有重要的信息，下面来简单了解一下。</p>
<h2 id="ETHREAD"><a href="#ETHREAD" class="headerlink" title="ETHREAD"></a>ETHREAD</h2><p>Windbg中，执行dt _ETHREAD可以看到这个完成的结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _ETHREAD</span><br><span class="line">ntdll!_ETHREAD</span><br><span class="line">   +0x000 Tcb              : _KTHREAD</span><br><span class="line">   +0x1c0 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x1c0 NestedFaultCount : Pos 0, 2 Bits</span><br><span class="line">   +0x1c0 ApcNeeded        : Pos 2, 1 Bit</span><br><span class="line">   +0x1c8 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x1c8 LpcReplyChain    : _LIST_ENTRY</span><br><span class="line">   +0x1c8 KeyedWaitChain   : _LIST_ENTRY</span><br><span class="line">   +0x1d0 ExitStatus       : Int4B</span><br><span class="line">   +0x1d0 OfsChain         : Ptr32 Void</span><br><span class="line">   +0x1d4 PostBlockList    : _LIST_ENTRY</span><br><span class="line">   +0x1dc TerminationPort  : Ptr32 _TERMINATION_PORT</span><br><span class="line">   +0x1dc ReaperLink       : Ptr32 _ETHREAD</span><br><span class="line">   +0x1dc KeyedWaitValue   : Ptr32 Void</span><br><span class="line">   +0x1e0 ActiveTimerListLock : Uint4B</span><br><span class="line">   +0x1e4 ActiveTimerListHead : _LIST_ENTRY</span><br><span class="line">   +0x1ec Cid              : _CLIENT_ID</span><br><span class="line">   +0x1f4 LpcReplySemaphore : _KSEMAPHORE</span><br><span class="line">   +0x1f4 KeyedWaitSemaphore : _KSEMAPHORE</span><br><span class="line">   +0x208 LpcReplyMessage  : Ptr32 Void</span><br><span class="line">   +0x208 LpcWaitingOnPort : Ptr32 Void</span><br><span class="line">   +0x20c ImpersonationInfo : Ptr32 _PS_IMPERSONATION_INFORMATION</span><br><span class="line">   +0x210 IrpList          : _LIST_ENTRY</span><br><span class="line">   +0x218 TopLevelIrp      : Uint4B</span><br><span class="line">   +0x21c DeviceToVerify   : Ptr32 _DEVICE_OBJECT</span><br><span class="line">   +0x220 ThreadsProcess   : Ptr32 _EPROCESS</span><br><span class="line">   +0x224 StartAddress     : Ptr32 Void</span><br><span class="line">   +0x228 Win32StartAddress : Ptr32 Void</span><br><span class="line">   +0x228 LpcReceivedMessageId : Uint4B</span><br><span class="line">   +0x22c ThreadListEntry  : _LIST_ENTRY</span><br><span class="line">   +0x234 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x238 ThreadLock       : _EX_PUSH_LOCK</span><br><span class="line">   +0x23c LpcReplyMessageId : Uint4B</span><br><span class="line">   +0x240 ReadClusterSize  : Uint4B</span><br><span class="line">   +0x244 GrantedAccess    : Uint4B</span><br><span class="line">   +0x248 CrossThreadFlags : Uint4B</span><br><span class="line">   +0x248 Terminated       : Pos 0, 1 Bit</span><br><span class="line">   +0x248 DeadThread       : Pos 1, 1 Bit</span><br><span class="line">   +0x248 HideFromDebugger : Pos 2, 1 Bit</span><br><span class="line">   +0x248 ActiveImpersonationInfo : Pos 3, 1 Bit</span><br><span class="line">   +0x248 SystemThread     : Pos 4, 1 Bit</span><br><span class="line">   +0x248 HardErrorsAreDisabled : Pos 5, 1 Bit</span><br><span class="line">   +0x248 BreakOnTermination : Pos 6, 1 Bit</span><br><span class="line">   +0x248 SkipCreationMsg  : Pos 7, 1 Bit</span><br><span class="line">   +0x248 SkipTerminationMsg : Pos 8, 1 Bit</span><br><span class="line">   +0x24c SameThreadPassiveFlags : Uint4B</span><br><span class="line">   +0x24c ActiveExWorker   : Pos 0, 1 Bit</span><br><span class="line">   +0x24c ExWorkerCanWaitUser : Pos 1, 1 Bit</span><br><span class="line">   +0x24c MemoryMaker      : Pos 2, 1 Bit</span><br><span class="line">   +0x250 SameThreadApcFlags : Uint4B</span><br><span class="line">   +0x250 LpcReceivedMsgIdValid : Pos 0, 1 Bit</span><br><span class="line">   +0x250 LpcExitThreadCalled : Pos 1, 1 Bit</span><br><span class="line">   +0x250 AddressSpaceOwner : Pos 2, 1 Bit</span><br><span class="line">   +0x254 ForwardClusterOnly : UChar</span><br><span class="line">   +0x255 DisablePageFaultClustering : UChar</span><br></pre></td></tr></table></figure>

<h3 id="0x000-Tcb"><a href="#0x000-Tcb" class="headerlink" title="+0x000 Tcb"></a>+0x000 Tcb</h3><ul>
<li>成员名：Tcb</li>
<li>数据类型：_KTHREAD</li>
<li>Windbg查询指令：dt _KTHREAD</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-20-09-e81b258f5d98142c853023fdd508bdbd-kthread-1a5a10.png"></p>
<ul>
<li>说明：KTHREAD这个结构应该已经比较眼熟了，在API函数的调用过程（保存现场），就多次用到了KTHREAD结构里的成员。</li>
</ul>
<h4 id="0x000-Header"><a href="#0x000-Header" class="headerlink" title="+0x000 Header"></a>+0x000 Header</h4><ul>
<li>成员名：Header</li>
<li>数据类型：_DISPATCHER_HEADER</li>
<li>说明：结构体内若包含_DISPATCHER_HEADER这个数据类型，说明这是一个可等待对象</li>
<li>可等待对象：Mutex，Event都是<strong>可等待对象</strong>，可被作用于WaitForSingleObject这类函数</li>
</ul>
<h4 id="0x018-InitialStack-x2F-0x01c-StackLimit-x2F-0x028-KernelStack"><a href="#0x018-InitialStack-x2F-0x01c-StackLimit-x2F-0x028-KernelStack" class="headerlink" title="+0x018 InitialStack&#x2F;+0x01c StackLimit&#x2F;+0x028 KernelStack"></a>+0x018 InitialStack&#x2F;+0x01c StackLimit&#x2F;+0x028 KernelStack</h4><ul>
<li>成员名：InitialStack&#x2F;StackLimit&#x2F;KernelStack</li>
<li>数据类型：Ptr32 Void</li>
<li>说明：这三个成员与线程切换有关。有印象的话，在分析KiFastCallEntry函数保存现场的过程中，曾有一行代码获取了InitialStack的值，并存到了ebp中。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-22-54-4c694c379b1f88d58c0f8900e90de2fa-initialStack-969b6a.png"></p>
<p> 此外，线程切换发生时，会根据KernelStack修改TSS的ESP0。更多关于这三个成员的用法，会在后面线程切换的地方再提到</p>
<h4 id="0x020-Teb"><a href="#0x020-Teb" class="headerlink" title="+0x020 Teb"></a>+0x020 Teb</h4><ul>
<li>成员名：Teb（Thread Environment Block），线程环境块</li>
<li>数据类型：Ptr32 Void</li>
<li>大小：4KB</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-22-46-36a66533193db4c33d8558bd2a477102-teb-3a3871.png"></p>
<ul>
<li>说明：<ul>
<li>0x20位置存着一个指向Teb结构的指针</li>
<li>Teb是在3环用来描述线程的一个结构。</li>
<li>0环时，FS:[0]指向KPCR；3环时，FS:[0]指向TEB</li>
</ul>
</li>
</ul>
<h4 id="0x02c-DebugActive"><a href="#0x02c-DebugActive" class="headerlink" title="+0x02c DebugActive"></a>+0x02c DebugActive</h4><ul>
<li>成员名：DebugActive</li>
<li>数据类型：UChar</li>
<li>说明：在分析KiSystemService进行保存现场的过中遇到过，若这个位置的值不是-1，说明处于调试状态，程序会跳转到执行一个将Dr0~Dr7保存到_Trap_Frame里面的操作。从而衍生出了一个反调试手段，将这个位置的值置为-1，从而不能使用8个调试寄存器</li>
</ul>
<h4 id="0x02d-State"><a href="#0x02d-State" class="headerlink" title="+0x02d State"></a>+0x02d State</h4><ul>
<li>成员名：State</li>
<li>数据类型：UChar</li>
<li>说明：<strong>线程状态</strong>-就绪&#x2F;等待&#x2F;运行</li>
</ul>
<h4 id="0x060-WaitListEntry-x2F-SwapListEntry"><a href="#0x060-WaitListEntry-x2F-SwapListEntry" class="headerlink" title="+0x060 WaitListEntry&#x2F;SwapListEntry"></a>+0x060 WaitListEntry&#x2F;SwapListEntry</h4><ul>
<li>成员名：WaitListEntry&#x2F;SwapListEntry</li>
<li>数据类型：WaitListEntry为_LIST_ENTRY &#x2F; SwapListEntry为 _SINGLE_LIST_ENTRY</li>
<li>说明：此处为Wait链表或Ready链表。Windows线程总是处于Wait&#x2F;Running&#x2F;Ready这三种状态之一</li>
</ul>
<h4 id="0x06c-BasePrioirty"><a href="#0x06c-BasePrioirty" class="headerlink" title="+0x06c BasePrioirty"></a>+0x06c BasePrioirty</h4><ul>
<li>成员名：BasePriority</li>
<li>数据类型：Char</li>
<li>说明：其初始值是所属进程的BasePrioirty值（KPROCESS-&gt;BasePriority），以后可以通过KeSetBasePriorityThread()函数重新设定</li>
</ul>
<h4 id="0x070-WaitBlock"><a href="#0x070-WaitBlock" class="headerlink" title="+0x070 WaitBlock"></a>+0x070 WaitBlock</h4><ul>
<li>成员名：WaitBlock</li>
<li>数据类型：[4]_KWAIT_BLOCK</li>
<li>说明：当前线程，正在等待哪个可等待对象（WaitForSingleObject）这个可等待对象的信息就会被写入这个_KWAIT_BLOCK结构的数组里。</li>
</ul>
<h4 id="0x0E0-ServiceTable"><a href="#0x0E0-ServiceTable" class="headerlink" title="+0x0E0 ServiceTable"></a>+0x0E0 ServiceTable</h4><ul>
<li>成员名：ServiceTable</li>
<li>数据类型：Ptr32 Void</li>
<li>说明：这个应该很熟悉了，指向系统服务表基址；通过系统服务表，可以找到函数地址表，根据系统服务号提供的偏移，就可以在函数地址表中找到3环API接口对应的0环内核函数</li>
</ul>
<h4 id="0x134-TrapFrame"><a href="#0x134-TrapFrame" class="headerlink" title="+0x134 TrapFrame"></a>+0x134 TrapFrame</h4><ul>
<li>成员名：TrapFrame</li>
<li>数据类型：Ptr32 _KTRAP_FRAME</li>
<li>说明：这个也很熟悉了，进0环时，保存现场的原理就是填充寄存器及相关数据到TrapFrame结构中，最后更新TrapFrame位置的值，使其指向新保存的TrapFrame</li>
</ul>
<h4 id="0x140-PerviousMode"><a href="#0x140-PerviousMode" class="headerlink" title="+0x140 PerviousMode"></a>+0x140 PerviousMode</h4><ul>
<li>成员名：PerviousMode</li>
<li>数据类型：Char</li>
<li>说明：在调用0环函数，保存现场的过程时，会<strong>将先前模式保存到TrapFrame结构中</strong>，以便根据先前模式，能够正确的返回到调用它的函数。</li>
</ul>
<h4 id="0x1b0-ThreadListEntry"><a href="#0x1b0-ThreadListEntry" class="headerlink" title="+0x1b0 ThreadListEntry"></a>+0x1b0 ThreadListEntry</h4><ul>
<li>成员名：ThreadListEntry</li>
<li>数据类型：_LIST_ENTRY</li>
<li>说明：<ul>
<li>双向链表，一个进程所有的线程，都挂在一个链表中，挂的就是这个位置</li>
<li><strong>链表头位于KPROCESS+0x50的位置以及EPROCESS+0x194的位置</strong>，相当于ThreadListEntry的PsThreadListHead</li>
<li>一共有两个这样的链表</li>
</ul>
</li>
</ul>
<h4 id="APC相关（位于KTHREAD内）"><a href="#APC相关（位于KTHREAD内）" class="headerlink" title="APC相关（位于KTHREAD内）"></a>APC相关（位于KTHREAD内）</h4><table>
<thead>
<tr>
<th>成员位置</th>
<th>成员名</th>
<th>数据类型</th>
</tr>
</thead>
<tbody><tr>
<td>0x034</td>
<td>ApcState</td>
<td>_KAPC_STATE</td>
</tr>
<tr>
<td>+0x0e8</td>
<td>ApcQueueLock</td>
<td>Uint4B</td>
</tr>
<tr>
<td>+0x138</td>
<td>ApcStatePointer</td>
<td>[2] Ptr32 _KAPC_STATE</td>
</tr>
<tr>
<td>+0x14c</td>
<td>SavedApcState</td>
<td>_KAPC_STATE</td>
</tr>
</tbody></table>
<ul>
<li>说明：这些均为与APC相关的结构，具体到APC章节再做分析，这里仅作了解</li>
</ul>
<h3 id="0x1ec-Cid"><a href="#0x1ec-Cid" class="headerlink" title="+0x1ec Cid"></a>+0x1ec Cid</h3><ul>
<li>成员名：Cid</li>
<li>数据类型：_CLIENT_ID</li>
<li>说明：共八字节，包含两个值，当前进程的PID和当前线程的CID</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-24-09-8b90bfbab972c8aa5b075b310d2650c8-cid-8ee9d8.png"></p>
<h3 id="0x220-ThreadProcess"><a href="#0x220-ThreadProcess" class="headerlink" title="+0x220 ThreadProcess"></a>+0x220 ThreadProcess</h3><ul>
<li>成员名：ThreadProcess</li>
<li>数据类型：Ptr32 _EPROCESS</li>
<li>说明：<strong>指向自己所属进程</strong></li>
</ul>
<h3 id="0x22c-ThreadListEntry"><a href="#0x22c-ThreadListEntry" class="headerlink" title="+0x22c ThreadListEntry"></a>+0x22c ThreadListEntry</h3><ul>
<li>成员名：ThreadListEntry</li>
<li>数据类型：_LIST_ENTRY</li>
<li>说明：<ul>
<li>双向链表，一个进程所有的线程，都挂在一个链表中，挂的就是这个位置</li>
<li><strong>链表头位于KPROCESS+0x50的位置以及EPROCESS+0x194的位置</strong>，相当于ThreadListEntry的PsThreadListHead</li>
<li>一共有两个这样的链表</li>
<li>这个双向链表的内容和0x1b0位置的完全一样，构建2个双向链表主要是为了方便，一个位于KPROCESS内，一个位于EPROCESS内</li>
</ul>
</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-24-29-8b989eaca0e49d523a1f5776c20bf124-threadListEntry-02bfda.png"></p>
<h2 id="关于断链"><a href="#关于断链" class="headerlink" title="关于断链"></a>关于断链</h2><p>在进程结构体中，我们通过断链实现了简单的进程隐藏，其原理在于，任务管理器在查询进程便是通过遍历ActiveProcessLink实现的。尽管进程已经不在活动进程链表上，但是仍然可以运行，原因是<strong>Windows调度的基本单位是线程，而不是进程</strong>，所以才有从进程链表上摘除自身进程的隐藏方法，这虽然从进程链表上摘除了自身，但不会影响操作系统的调度，所以不影响程序运行。</p>
<p>接下来是线程断链的实验：</p>
<ol>
<li>!process EPROCESS 可以查看进程里有几个线程，一般来说，第一个就是GUI线程或者主线程。这次作业就不写代码了，直接打开一个程序，用windbg断链，这里打开的是dbgview.exe，它有两个线程</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-41-37-be6b2c49a6de9ab8ef81fdd381b4f22e-20201106153214579-b907a5.png"></p>
<ol start="2">
<li>在windbg里找到dbgview的EPROCESS(82017990)，把+0x50和+0x190两个链表断掉</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; ed 82017990+194 82017990+194</span><br><span class="line">kd&gt; ed 82017990+190 82017990+190</span><br><span class="line">kd&gt; ed 82017990+50 82017990+50</span><br><span class="line">kd&gt; ed 82017990+54 82017990+54</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>用windbg看看线程，发现都没了</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; !process 82017990  </span><br><span class="line">PROCESS 82017990  SessionId: 0  Cid: 00b0    Peb: 7ffde000  ParentCid: 01d4</span><br><span class="line">    DirBase: 095002c0  ObjectTable: e1b610d0  HandleCount:  59.</span><br><span class="line">    Image: Dbgview.exe</span><br><span class="line">    VadRoot 81c4ca50 Vads 65 Clone 0 Private 339. Modified 22. Locked 0.</span><br><span class="line">    DeviceMap e1b8e9e8</span><br><span class="line">    Token                             e1207940</span><br><span class="line">    ElapsedTime                       00:12:24.734</span><br><span class="line">    UserTime                          00:00:00.078</span><br><span class="line">    KernelTime                        00:00:00.500</span><br><span class="line">    QuotaPoolUsage[PagedPool]         57940</span><br><span class="line">    QuotaPoolUsage[NonPagedPool]      2680</span><br><span class="line">    Working Set Sizes (now,min,max)  (3060, 50, 345) (12240KB, 200KB, 1380KB)</span><br><span class="line">    PeakWorkingSetSize                3060</span><br><span class="line">    VirtualSize                       30 Mb</span><br><span class="line">    PeakVirtualSize                   32 Mb</span><br><span class="line">    PageFaultCount                    3198</span><br><span class="line">    MemoryPriority                    BACKGROUND</span><br><span class="line">    BasePriority                      8</span><br><span class="line">    CommitCharge                      403</span><br><span class="line">    DebugPort                         81ed9ac0</span><br><span class="line"></span><br><span class="line">TYPE mismatch for thread object at 82017830</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>重新用OD附加，发现附加失败</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-14-48-43-0016889f516e05e4c8d34434ef3548ed-20201106154040260-232995.png"></p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程结构体</title>
    <url>/2022/03/29/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进程，站在内核的角度来说，它就是个结构体。当操作系统想要创建一个进程时，本质上就是<strong>分配一块内存，填充一个结构体</strong>，今天就来了解一下这个进程结构体EPROCESS。</p>
<h2 id="EPROCESS"><a href="#EPROCESS" class="headerlink" title="EPROCESS"></a>EPROCESS</h2><p>每个Windows进程在0环都有一个对应的结构体：EPROCESS，这个结构体包含了进程所有重要的信息。</p>
<p>在Windbg中，执行指令dt _EPROCESS 我们就可以看到这个完整的结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">ntdll!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x070 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x078 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x080 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x084 UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +0x088 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x090 QuotaUsage       : [3] Uint4B</span><br><span class="line">   +0x09c QuotaPeak        : [3] Uint4B</span><br><span class="line">   +0x0a8 CommitCharge     : Uint4B</span><br><span class="line">   +0x0ac PeakVirtualSize  : Uint4B</span><br><span class="line">   +0x0b0 VirtualSize      : Uint4B</span><br><span class="line">   +0x0b4 SessionProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x0bc DebugPort        : Ptr32 Void</span><br><span class="line">   +0x0c0 ExceptionPort    : Ptr32 Void</span><br><span class="line">   +0x0c4 ObjectTable      : Ptr32 _HANDLE_TABLE</span><br><span class="line">   +0x0c8 Token            : _EX_FAST_REF</span><br><span class="line">   +0x0cc WorkingSetLock   : _FAST_MUTEX</span><br><span class="line">   +0x0ec WorkingSetPage   : Uint4B</span><br><span class="line">   +0x0f0 AddressCreationLock : _FAST_MUTEX</span><br><span class="line">   +0x110 HyperSpaceLock   : Uint4B</span><br><span class="line">   +0x114 ForkInProgress   : Ptr32 _ETHREAD</span><br><span class="line">   +0x118 HardwareTrigger  : Uint4B</span><br><span class="line">   +0x11c VadRoot          : Ptr32 Void</span><br><span class="line">   +0x120 VadHint          : Ptr32 Void</span><br><span class="line">   +0x124 CloneRoot        : Ptr32 Void</span><br><span class="line">   +0x128 NumberOfPrivatePages : Uint4B</span><br><span class="line">   +0x12c NumberOfLockedPages : Uint4B</span><br><span class="line">   +0x130 Win32Process     : Ptr32 Void</span><br><span class="line">   +0x134 Job              : Ptr32 _EJOB</span><br><span class="line">   +0x138 SectionObject    : Ptr32 Void</span><br><span class="line">   +0x13c SectionBaseAddress : Ptr32 Void</span><br><span class="line">   +0x140 QuotaBlock       : Ptr32 _EPROCESS_QUOTA_BLOCK</span><br><span class="line">   +0x144 WorkingSetWatch  : Ptr32 _PAGEFAULT_HISTORY</span><br><span class="line">   +0x148 Win32WindowStation : Ptr32 Void</span><br><span class="line">   +0x14c InheritedFromUniqueProcessId : Ptr32 Void</span><br><span class="line">   +0x150 LdtInformation   : Ptr32 Void</span><br><span class="line">   +0x154 VadFreeHint      : Ptr32 Void</span><br><span class="line">   +0x158 VdmObjects       : Ptr32 Void</span><br><span class="line">   +0x15c DeviceMap        : Ptr32 Void</span><br><span class="line">   +0x160 PhysicalVadList  : _LIST_ENTRY</span><br><span class="line">   +0x168 PageDirectoryPte : _HARDWARE_PTE_X86</span><br><span class="line">   +0x168 Filler           : Uint8B</span><br><span class="line">   +0x170 Session          : Ptr32 Void</span><br><span class="line">   +0x174 ImageFileName    : [16] UChar</span><br><span class="line">   +0x184 JobLinks         : _LIST_ENTRY</span><br><span class="line">   +0x18c LockedPagesList  : Ptr32 Void</span><br><span class="line">   +0x190 ThreadListHead   : _LIST_ENTRY</span><br><span class="line">   +0x198 SecurityPort     : Ptr32 Void</span><br><span class="line">   +0x19c PaeTop           : Ptr32 Void</span><br><span class="line">   +0x1a0 ActiveThreads    : Uint4B</span><br><span class="line">   +0x1a4 GrantedAccess    : Uint4B</span><br><span class="line">   +0x1a8 DefaultHardErrorProcessing : Uint4B</span><br><span class="line">   +0x1ac LastThreadExitStatus : Int4B</span><br><span class="line">   +0x1b0 Peb              : Ptr32 _PEB</span><br><span class="line">   +0x1b4 PrefetchTrace    : _EX_FAST_REF</span><br><span class="line">   +0x1b8 ReadOperationCount : _LARGE_INTEGER</span><br><span class="line">   +0x1c0 WriteOperationCount : _LARGE_INTEGER</span><br><span class="line">   +0x1c8 OtherOperationCount : _LARGE_INTEGER</span><br><span class="line">   +0x1d0 ReadTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x1d8 WriteTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x1e0 OtherTransferCount : _LARGE_INTEGER</span><br><span class="line">   +0x1e8 CommitChargeLimit : Uint4B</span><br><span class="line">   +0x1ec CommitChargePeak : Uint4B</span><br><span class="line">   +0x1f0 AweInfo          : Ptr32 Void</span><br><span class="line">   +0x1f4 SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   +0x1f8 Vm               : _MMSUPPORT</span><br><span class="line">   +0x238 LastFaultCount   : Uint4B</span><br><span class="line">   +0x23c ModifiedPageCount : Uint4B</span><br><span class="line">   +0x240 NumberOfVads     : Uint4B</span><br><span class="line">   +0x244 JobStatus        : Uint4B</span><br><span class="line">   +0x248 Flags            : Uint4B</span><br><span class="line">   +0x248 CreateReported   : Pos 0, 1 Bit</span><br><span class="line">   +0x248 NoDebugInherit   : Pos 1, 1 Bit</span><br><span class="line">   +0x248 ProcessExiting   : Pos 2, 1 Bit</span><br><span class="line">   +0x248 ProcessDelete    : Pos 3, 1 Bit</span><br><span class="line">   +0x248 Wow64SplitPages  : Pos 4, 1 Bit</span><br><span class="line">   +0x248 VmDeleted        : Pos 5, 1 Bit</span><br><span class="line">   +0x248 OutswapEnabled   : Pos 6, 1 Bit</span><br><span class="line">   +0x248 Outswapped       : Pos 7, 1 Bit</span><br><span class="line">   +0x248 ForkFailed       : Pos 8, 1 Bit</span><br><span class="line">   +0x248 HasPhysicalVad   : Pos 9, 1 Bit</span><br><span class="line">   +0x248 AddressSpaceInitialized : Pos 10, 2 Bits</span><br><span class="line">   +0x248 SetTimerResolution : Pos 12, 1 Bit</span><br><span class="line">   +0x248 BreakOnTermination : Pos 13, 1 Bit</span><br><span class="line">   +0x248 SessionCreationUnderway : Pos 14, 1 Bit</span><br><span class="line">   +0x248 WriteWatch       : Pos 15, 1 Bit</span><br><span class="line">   +0x248 ProcessInSession : Pos 16, 1 Bit</span><br><span class="line">   +0x248 OverrideAddressSpace : Pos 17, 1 Bit</span><br><span class="line">   +0x248 HasAddressSpace  : Pos 18, 1 Bit</span><br><span class="line">   +0x248 LaunchPrefetched : Pos 19, 1 Bit</span><br><span class="line">   +0x248 InjectInpageErrors : Pos 20, 1 Bit</span><br><span class="line">   +0x248 VmTopDown        : Pos 21, 1 Bit</span><br><span class="line">   +0x248 Unused3          : Pos 22, 1 Bit</span><br><span class="line">   +0x248 Unused4          : Pos 23, 1 Bit</span><br><span class="line">   +0x248 VdmAllowed       : Pos 24, 1 Bit</span><br><span class="line">   +0x248 Unused           : Pos 25, 5 Bits</span><br><span class="line">   +0x248 Unused1          : Pos 30, 1 Bit</span><br><span class="line">   +0x248 Unused2          : Pos 31, 1 Bit</span><br><span class="line">   +0x24c ExitStatus       : Int4B</span><br><span class="line">   +0x250 NextPageColor    : Uint2B</span><br><span class="line">   +0x252 SubSystemMinorVersion : UChar</span><br><span class="line">   +0x253 SubSystemMajorVersion : UChar</span><br><span class="line">   +0x252 SubSystemVersion : Uint2B</span><br><span class="line">   +0x254 PriorityClass    : UChar</span><br><span class="line">   +0x255 WorkingSetAcquiredUnsafe : UChar</span><br><span class="line">   +0x258 Cookie           : Uint4B</span><br></pre></td></tr></table></figure>

<p>这个结构体非常大，本篇先介绍一些比较关键的字段，其余在后续文章中用到时再详细介绍。</p>
<h3 id="0x000-Pcb"><a href="#0x000-Pcb" class="headerlink" title="+0x000 Pcb"></a>+0x000 Pcb</h3><ul>
<li>成员名：Pcb</li>
<li>数据类型：_KPROCESS</li>
<li>说明：在EPROCESS开始的位置，有一个Pcb，它是一个KPROCESS结构，同样包含了描述进程的信息，先来看一下这个结构比较关键的一些字段。</li>
<li>结构体：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-31-25-b889d8a02e9dae08f1a37b64a0a00f9a-20191111184840333-7c12f7.png"></p>
<h4 id="0x000-Header"><a href="#0x000-Header" class="headerlink" title="+0x000 Header"></a>+0x000 Header</h4><ul>
<li>成员名：Header</li>
<li>数据类型：_DISPATCHER_HEADER</li>
<li>说明：结构体内若包含_DISPATCHER_HEADER这个数据类型，说明这是一个可等待对象</li>
<li>可等待对象：Mutex，Event都是可等待对象，可被作用于WaitForSingleObject这类函数</li>
</ul>
<h4 id="0x018-DirectoryTableBase"><a href="#0x018-DirectoryTableBase" class="headerlink" title="+0x018 DirectoryTableBase"></a>+0x018 DirectoryTableBase</h4><ul>
<li>成员名：<strong>页目录表基址</strong></li>
<li>数据类型：[2] Uint4B</li>
<li>说明：<strong>进程结构体中最重要的成员</strong>，控制整个进程的物理页，进程切换时会将值填入Cr3</li>
</ul>
<h4 id="0x038-KernelTime-x2F-0x03c-UserTime"><a href="#0x038-KernelTime-x2F-0x03c-UserTime" class="headerlink" title="+0x038 KernelTime&#x2F;+0x03c UserTime"></a>+0x038 KernelTime&#x2F;+0x03c UserTime</h4><ul>
<li>成员名：KernelTime&#x2F;UserTime</li>
<li>数据类型：Uint4B</li>
<li>说明：统计信息，记录了一个进程在内核模式&#x2F;用户模式下所花的时间</li>
</ul>
<h4 id="0x050-ThreadListHead"><a href="#0x050-ThreadListHead" class="headerlink" title="+0x050 ThreadListHead"></a>+0x050 ThreadListHead</h4><ul>
<li>成员名：ThreadListHead</li>
<li>数据类型：_LIST_ENTRY</li>
<li>说明：指向当前进程的，线程链表</li>
</ul>
<h4 id="0x05c-Affinity"><a href="#0x05c-Affinity" class="headerlink" title="+0x05c Affinity"></a>+0x05c Affinity</h4><ul>
<li><p>成员名：Affinity</p>
</li>
<li><p>数据类型：Uint4B</p>
</li>
<li><p>说明：规定进程里面的所有线程能在哪个CPU上跑</p>
<ul>
<li>如果值为1，那这个进程的所有线程只能在0号CPU上跑（00000001）</li>
<li>如果值为3，那这个进程的所有线程能在0、1号CPU上跑（000000011）</li>
<li>如果值为4，那这个进程的所有线程能在2号CPU上跑（000000100）</li>
<li>如果值为5，那这个进程的所有线程能在0，2号CPU上跑（000000101）</li>
</ul>
<p>4个字节共32位，所以最多只能32核，Windows64位，就64核；如果只有一个CPU，把这个值设置为4，那么这个进程就死了。</p>
</li>
</ul>
<h4 id="0x062-BasePriority"><a href="#0x062-BasePriority" class="headerlink" title="+0x062 BasePriority"></a>+0x062 BasePriority</h4><ul>
<li>成员名：BasePriority</li>
<li>数据类型：Char</li>
<li>说明：表示基础优先级&#x2F;最低优先级，该进程中的所有线程一创建出来时最初的优先级</li>
</ul>
<p>到这里KPROCESS内部的主要成员就介绍完了，现在又要回到EPROCESS这个结构中了</p>
<h4 id="0x063-ThreadQuantum"><a href="#0x063-ThreadQuantum" class="headerlink" title="+0x063 ThreadQuantum"></a>+0x063 ThreadQuantum</h4><ul>
<li>成员名：ThreadQuantum</li>
<li>数据类型：Char</li>
<li>说明：线程时间片的初始值</li>
</ul>
<h3 id="0x070-CreateTime-x2F-0x078-ExitTime"><a href="#0x070-CreateTime-x2F-0x078-ExitTime" class="headerlink" title="+0x070 CreateTime&#x2F;+0x078 ExitTime"></a>+0x070 CreateTime&#x2F;+0x078 ExitTime</h3><ul>
<li>成员名：CreateTime&#x2F;ExitTime</li>
<li>数据类型：_LARGE_INTEGER</li>
<li>说明：进程的创建&#x2F;退出时间</li>
</ul>
<h3 id="0x084-UniqueProcessId"><a href="#0x084-UniqueProcessId" class="headerlink" title="+0x084 UniqueProcessId"></a>+0x084 UniqueProcessId</h3><ul>
<li>成员名：UniqueProcessId</li>
<li>数据类型：Ptr32 Void</li>
<li>说明：进程的编号，<strong>任务管理器中显示的PID</strong>就是这个值</li>
</ul>
<h3 id="0x088-ActiveProcessLinks"><a href="#0x088-ActiveProcessLinks" class="headerlink" title="+0x088 ActiveProcessLinks"></a>+0x088 ActiveProcessLinks</h3><ul>
<li>成员名：ActiveProcessLinks</li>
<li>数据类型：_List_Entry</li>
<li>说明：双向链表，所有的活动进程都连接在一起，构成了一个链表<ul>
<li>PsActiveProcessHead指向全局链表头</li>
<li>第一个成员<strong>指向后一个进程结构体0x88偏移的位置</strong>，第二个成员<strong>指向前一个结构体0x88偏移的位置</strong></li>
<li>通过断链，可以实现简单的进程隐藏</li>
</ul>
</li>
<li>结构图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-41-53-eb33fc1ece19fa38dcf64e9bc3845001-activeProcessLinks-1d4f8f.png"></p>
<ul>
<li>查询示范：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-42-13-1a2af8fc8b406cd03dbe39d361eefd57-queryAPL-d5a39e.png"></p>
<h3 id="0x090-QuotaUsage-x2F-0x09c-QuotaPeak"><a href="#0x090-QuotaUsage-x2F-0x09c-QuotaPeak" class="headerlink" title="+0x090 QuotaUsage&#x2F;+0x09c QuotaPeak"></a>+0x090 QuotaUsage&#x2F;+0x09c QuotaPeak</h3><ul>
<li>成员名：QuotaUsage&#x2F;QuotaPeak</li>
<li>数据类型：[3] Uint4B</li>
<li>说明：物理页相关的统计信息（到内存部分会详细分析）</li>
</ul>
<h3 id="0x0a8-CommitCharge-x2F-0x0ac-PeakVirtualSize-x2F-0x0b0-VirtualSize"><a href="#0x0a8-CommitCharge-x2F-0x0ac-PeakVirtualSize-x2F-0x0b0-VirtualSize" class="headerlink" title="+0x0a8 CommitCharge&#x2F;+0x0ac PeakVirtualSize&#x2F;+0x0b0 VirtualSize"></a>+0x0a8 CommitCharge&#x2F;+0x0ac PeakVirtualSize&#x2F;+0x0b0 VirtualSize</h3><ul>
<li>成员名：CommitCharge&#x2F;PeakVirtualSize&#x2F;VirtualSize</li>
<li>数据类型：Uint4B</li>
<li>说明：虚拟内存相关的统计信息（到内存部分会详细分析）</li>
</ul>
<h3 id="0x11c-VadRoot"><a href="#0x11c-VadRoot" class="headerlink" title="+0x11c VadRoot"></a>+0x11c VadRoot</h3><ul>
<li>成员名：VadRoot</li>
<li>数据类型：Ptr32 Void</li>
<li>说明：指向一个平衡二叉树，标识了0~2G哪些内存被分配了，哪些没被分配；该成员和内存遍历，模块隐藏有关</li>
</ul>
<h3 id="0x0bc-DebugPort-x2F-0x0c0-ExceptionPort"><a href="#0x0bc-DebugPort-x2F-0x0c0-ExceptionPort" class="headerlink" title="+0x0bc DebugPort &#x2F;+0x0c0 ExceptionPort"></a>+0x0bc DebugPort &#x2F;+0x0c0 ExceptionPort</h3><ul>
<li>成员名：DebugPort&#x2F;ExceptionPort</li>
<li>数据类型：Ptr32 Void</li>
<li>说明：调试相关，通过清零DebugPort，是一种简单的反调试手段，具体关于调试的内容，到调试相关章节会详细分析</li>
</ul>
<h3 id="0x0c4-ObjectTable"><a href="#0x0c4-ObjectTable" class="headerlink" title="+0x0c4 ObjectTable"></a>+0x0c4 ObjectTable</h3><ul>
<li>成员名：ObjectTable</li>
<li>数据类型：Ptr32 _HANDLE_TABLE</li>
<li>说明：句柄表，存储在0环，<strong>记录了当前进程所使用的别的进程的句柄地址</strong>，可以通过遍历所有进程的句柄表来查看当前程序是否被调试。在句柄表的章节，会详细讲解这个成员的内容</li>
</ul>
<h3 id="0x174-ImageFileName"><a href="#0x174-ImageFileName" class="headerlink" title="+0x174 ImageFileName"></a>+0x174 ImageFileName</h3><ul>
<li>成员名：ImageFileName</li>
<li>数据类型：[16]UChar</li>
<li>说明：进程镜像文件名，最多16个字节。如上面查询活动进程链表的实验中，可以看到进程名为”System”</li>
</ul>
<h3 id="0x1a0-ActiveThreads"><a href="#0x1a0-ActiveThreads" class="headerlink" title="0x1a0 ActiveThreads"></a>0x1a0 ActiveThreads</h3><ul>
<li>成员名：ActiveThreads</li>
<li>数据类型：Uint4B</li>
<li>说明：活动线程的数量</li>
</ul>
<h3 id="0x1b0-Peb"><a href="#0x1b0-Peb" class="headerlink" title="0x1b0 Peb"></a>0x1b0 Peb</h3><ul>
<li>成员名：Peb</li>
<li>数据类型：Ptr32_PEB</li>
<li>说明：PEB（Process Enviroment Block 进程环境快）：位于3环的一个描述进程的结构，里面包含了进程的<strong>模块列表</strong>、是否处于调试状态，等信息</li>
<li>结构图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-42-51-233bb28f5323674c91cf77236a642731-peb-5ffce6.png" alt="PEB"></p>
<p>下面简单介绍其中2个成员：</p>
<h4 id="0x2-BeingDebugged"><a href="#0x2-BeingDebugged" class="headerlink" title="0x2 BeingDebugged"></a>0x2 BeingDebugged</h4><ul>
<li>成员名：BeingDebugged</li>
<li>数据类型：Uchar</li>
<li>说明：当进程属于被调试的时候，这个位置的值会被置1。调试器可以通过不断清零这个值，做到简单的反反调试</li>
</ul>
<h4 id="0xc-Ldr"><a href="#0xc-Ldr" class="headerlink" title="0xc Ldr"></a>0xc Ldr</h4><ul>
<li>成员名：Ldr</li>
<li>数据类型：_PEB_LDR_DATA</li>
<li>该结构内有3个双向链表成员，<strong>存储了当前进程所有的模块</strong>（只是顺序不同），通过<strong>断链可以实现简单的模块隐藏</strong></li>
<li>结构图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-48-37-cf40621d6e43be0cc367e39cb97e6e1c-ldr-34beff.png"></p>
<h2 id="进程隐藏"><a href="#进程隐藏" class="headerlink" title="进程隐藏"></a>进程隐藏</h2><p>在前面介绍了EPROCESS里有一个双向链表ActiveProcessLinks，我们可以通过断链，实现简单的进程隐藏。</p>
<ol>
<li>打开OD，然后打开任务管理器，可以看到，OD这个进程</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-49-21-0b5d20e64ee57a07039258fcaeb2273e-hideProcessBefore-d7ac8c.png"></p>
<ol start="2">
<li>然后找到活动进程链表头</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-51-30-dd32ba59530a747aec454ea27b1c196d-aph-dfa167.png"></p>
<ol start="3">
<li>从后往前遍历（刚打开的进程，位于链表靠后的位置），找到OD这个进程对应的EPROCESS</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-52-41-6a6ff85ec82d4751d17d8322e034d6cf-od-bec288.png"></p>
<ol start="4">
<li>修改OD前后进程结构体的活动进程链表，将OD断链</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-53-21-d2671fccbfd22ce47193c0dbba7df7b2-odOut-0eb877.png"></p>
<ol start="5">
<li>再次打开任务管理器，发现没有OD这个进程了，但是程序仍能正常执行</li>
</ol>
<p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-11-54-02-efca31f233eb2c4a82e7bd1bf5bfc7ad-hideProcessAfter-92717d.png"></p>
<ol start="6">
<li>说明任务管理器是通过<strong>遍历活动进程链表来查询所有进程的</strong></li>
</ol>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>分析SwapContext</title>
    <url>/2022/04/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E5%88%86%E6%9E%90SwapContext/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SwapContext这个函数是Windows线程切换的核心，无论是<strong>主动切换</strong>还是<strong>系统时钟导致的线程切换</strong>，最终都会调用这个函数。在这个函数中，除了切换堆栈以外，还做了一些其它事情，了解这些细节对我们学习操作系统至关重要。</p>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>在分析SwapContext函数之前，来回顾两个之前的文章中并没有交代的问题：</p>
<ul>
<li><p>我们知道，在程序从3环进入0环时，会发生<strong>权限的切换</strong>，这就<strong>意味着堆栈发生了切换</strong>，也必然，<strong>线程发生了切换</strong>。之前学习过，3环进入0环，有两种方式，分别是中断门进0环以及快速调用。这里我们来简单的回顾一下：</p>
<ul>
<li>通过中断门进0环时，会<strong>从TSS中获取到esp0</strong>的值。</li>
<li>快速调用进入0环时，则是从MSR寄存器中获取esp0的值，但是实际情况是，在分析快速调用进0环使用的KiFastCallEntry函数时，我们发现，<strong>快速调用进入0环时也是通过TSS来获取esp0</strong>的值的，所以MSR寄存器给的值，实际上只是作为中间过渡用<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-53-39-a106304f84912ca9563917ad05d96832-kfce-d9e77d.png"></li>
</ul>
<p>那么问题来了，TSS寄存器里面的这个<strong>esp0</strong>，到底是<strong>哪来的</strong>？如何保证<strong>每次切换线程后</strong>，TSS中的<strong>esp0对应的仍然是当前线程的</strong>esp0呢？分析SwapContext函数时便会找到答案。</p>
</li>
<li><p>另一个问题呢，是关于FS的；我们知道FS:[0]寄存器在<strong>3环时指向TEB</strong>，<strong>进入0环</strong>后FS:[0]<strong>指向KPCR</strong>；系统中同时存在很多个线程，那该<strong>如何保证</strong>FS:[0]在3环时一定是<strong>指向的当前正在运行的线程</strong>呢？同样，想知道这个答案，我们也需要通过分析SwapContext函数来解开。</p>
</li>
</ul>
<h2 id="SwapContext"><a href="#SwapContext" class="headerlink" title="SwapContext"></a>SwapContext</h2><p>SwapContext函数比较长，就分为5个部分来进行分析，当然，这<strong>5个部分是连续</strong>的。另外，由于我已经在IDA中分析好了，这里就不贴上源码，直接通过图片来分析了。</p>
<h3 id="Part1"><a href="#Part1" class="headerlink" title="Part1"></a>Part1</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-54-04-c388fe356e36c857eb27e886afe69fb6-part1-7e8102.png"></p>
<ol>
<li><p>来看看这部分做了些啥事，首先将**目前线程(即将切换的线程)**的线程状态置为2。这一部分有几个外部通过寄存器传进来的参数的含义，具体可以看图</p>
</li>
<li><p>第二步<strong>将Eflags入栈</strong>，在线程切换时，会有很多判断操作，势必会影响到标志寄存器的值，这里需要保存一下</p>
</li>
<li><p>接下来的4行，放在一起看。这里有两个操作：</p>
<p>1）将ExceptionList入栈，由于将发生线程切换，需要<strong>保存当前线程的异常链表</strong>。ebx指向的KPCR，所以**[ebx]的值刚好是KPCR的第一个成员NtTib内的第一个成员**，也就是ExceptionList</p>
<p>2）KPCR+0x994的位置是DPCRoutineActive，<strong>DPC是延迟过程调用</strong>，和APC相对，这里不再扩展，需要注意一点，这个会有个判断，<strong>如果DPCRoutineActive的值不为0，那就执行蓝屏程序</strong></p>
</li>
<li><p>第四步，这个_PPerfGlobalGroupMask，仅仅在Windows Server2003中，5.2版本出现的一个字段，位于NtTib+0x08的位置，主要<strong>与日志，调式相关</strong>的。</p>
</li>
<li><p>到这就差不多了，接下来从mov ebp, cr0这条指令开始，开始第二部分的分析</p>
</li>
</ol>
<h3 id="Part2"><a href="#Part2" class="headerlink" title="Part2"></a>Part2</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-54-26-df9540866d48cf13f9773ff54b58d3b1-part2-875dba.png"></p>
<ol>
<li><p>来看第二部分，先让edx获取当前线程的Cr0寄存器的值。这里仅作暂存，具体后面会用到</p>
</li>
<li><p>KPCR中需要保存<strong>当前线程的相关信息</strong>，所以接下来，获取到<strong>目标线程的DebugActive</strong>写入到KPCR的DebugActive位上</p>
</li>
<li><p>这一步，比较好理解。毕竟一会要进行线程切换，总不能切换到一半去执行别的任务吧。因此就把中断屏蔽了</p>
</li>
<li><p><strong>保存当前线程的esp到KernelStack</strong>字段中，这是我们熟知的<strong>经典线程切换操作的第一步</strong>。为什么没有紧接着进行第二步的操作呢？因为还有一些细节需要处理。接着往下看</p>
</li>
<li><p>第五步，主要做一些准备工作，这里能有两个操作，分别来看看</p>
<p>1）将目标线程的StackLimit保存到KPCR的StackLimit位置上</p>
<p>2）将目标线程的InitialStack处的值减去0x210后，赋到StackBase上。为什么要减去0x210呢？这里涉及到了内核堆栈的结构<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-54-59-6c3497092b0da4a0354ae1c144d7193a-kernelStack-1da122.png"><br>每个线程的内核堆栈，栈底开始共有<strong>0x210个字节用于存储浮点寄存器</strong>相关的内容。因此KPCR中记录的栈基址需要减去0x210个字节</p>
</li>
<li><p>第六步，仍然是与浮点寄存器相关，在KTHREAD+0x031的位置，有一个字段叫做NpxState。这里主要是判断NpxState有没有浮点支持，以及上一个线程和当前线程对于浮点的支持是否相同，来决定是否需要重新修改Cr0寄存器的值。</p>
</li>
<li><p>下一部分，从loc_80004983开始</p>
</li>
</ol>
<h3 id="Part3"><a href="#Part3" class="headerlink" title="Part3"></a>Part3</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-55-57-c78d63e314424d2885cfc3b0e97e5db7-part3-3c2b58.png"></p>
<ol>
<li><p>这部分内容较多，慢慢来看，第一步eax-0x10，结合Part2的分析可以知道，eax刚刚提升了0x210个字节，用于存储浮点寄存器相关内容，这里又提升0x10个字节的目的，同样可以根据上图可知，**_Trap_Frame结构的开始部分<strong>，有</strong>0x10字节<strong>存储的内容是</strong>用于虚拟8086模式**下的值，因此这里再次提升0x10字节的堆栈</p>
</li>
<li><p>第二步是最为关键的一步，这里实现了两个关键的操作：</p>
<p>1）将eax存的值赋值给TSS.esp0的位置，之前分析3环进0环时，有提到过，进入0环后的esp的位置，这里回顾一下：<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-57-20-b51d82357959d008f400b4865b55581b-trapFrame-255d59.png"><br>而此时，<strong>eax所存的值，刚好位于快速调用进0环后esp所处的位置</strong>(<strong>InitialStack-0x210-0x10</strong>)。所以这个值，就<strong>是3环进0环后esp0的值</strong>，此处将这个值赋值给了TSS.esp0，自然也就<strong>解释了为什么TSS中存的esp0总是指向当前线程的0环堆栈</strong>，原因就是，<strong>每次堆栈切换发生时</strong>，SwapContext函数内，都会将切换后，<strong>线程堆栈栈顶存储到TSS.esp0的位置</strong></p>
<p>2）第二个操作，哎，是我们非常熟悉的<strong>线程切换的经典步骤第二步</strong>，切换堆栈。这里就不多解释了，总之，至此，<strong>堆栈切换完成</strong>了，但是还是有一些善后工作需要处理。相比海哥的ThreadSwitch模拟切换函数来说，SwapContext还是略微复杂些的。</p>
</li>
<li><p>第三步，很容易看懂，设置KPCR.NtTib.Self指向Teb。这步有啥用呢？到Part4就能明白啦</p>
</li>
<li><p>第四步，就做了一个事，判断线程切换前后的2个线程，是不是属于同一个进程，方法也很简单，分别取两个线程KTHREAD+0x44位置指向的值（这里要注意下，在KTHREAD+0x34的偏移处，有一个ApcState结构体，其中+0x10位置<strong>存着指向当前线程所属进程的指针</strong>）<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-56-53-867c73e21ab3cb92e8ee83674fe2d113-apcState-b417d7.png"><br>然后比较一下，若值不相同的话，那就将<strong>新的线程所属进程结构体的指针</strong>保存到edi中</p>
</li>
<li><p>第五步，紧接着第四步继续，如果俩线程的所属进程不同，就会走到这一步。这一步也有两个操作：</p>
<p>1）<strong>因为进程切换</strong>了，因此Cr3的值也要跟着变，因此这里从新的进程中获取Cr3，并保存到TSS中</p>
<p>2）同理，另一个需要更新的值，IO位图，也就是TSS最后一个元素，当然，这个值不重要，详情见图</p>
</li>
<li><p>下一部分，从loc_800049D7开始</p>
</li>
</ol>
<h3 id="Part4"><a href="#Part4" class="headerlink" title="Part4"></a>Part4</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-57-08-022aa8148053c169d9cb9dcde3d9e92e-part4-516a6f.png"></p>
<ol>
<li>这一部分，也就做一些收尾工作了，毕竟线程切换已经完了嘛。这里的第一步，最为关键。Part3的第三步，让<strong>KPCR.NtTib.Self指向了Teb</strong>。这里就用上了。我们有了这个Teb的地址后，就通过移位，将这个地址分3个部分(根据段描述符的结构)，<strong>写入到GDT表中，下标为7的这个段描述符中</strong>。这个段描述符<strong>对应的段选择子是0x3B</strong>，也就是3环FS寄存器存着的段选择子。这就解释了文章开头提到的第二个问题，为什么3环FS:[0]指向的一定是当前线程的Teb，原因就在这里，因为<strong>每次线程切换</strong>时，都会<strong>给3环FS:[0]对应的段描述符赋上当前线程Teb的地址</strong></li>
<li>第二步，主要做了一些统计相关的操作，例如，CPU发生了多少次线程切换，以及这个线程被切换了多少次</li>
<li>第三步，主要做了一些恢复现场的工作，具体看图中注释。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，SwapContext函数已分析完毕，我们进一步了解了线程切换的细节，以及线程切换时，对TSS，FS的影响</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>时间片管理与备用线程</title>
    <url>/2022/04/04/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E6%97%B6%E9%97%B4%E7%89%87%E7%AE%A1%E7%90%86%E4%B8%8E%E5%A4%87%E7%94%A8%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇，我们主要分析了线程切换的几种情况，其中一种是<strong>时钟中断</strong>，但并不是说只要有时钟中断就一定会切换线程，时钟中断时，两种情况会导致线程切换：</p>
<ul>
<li>当前<strong>线程的CPU时间片到期</strong></li>
<li>存在备用线程（KPCR.PrcbData.NextThread处值不为空）</li>
</ul>
<h2 id="CPU时间片"><a href="#CPU时间片" class="headerlink" title="CPU时间片"></a>CPU时间片</h2><h3 id="ThreadQuantum"><a href="#ThreadQuantum" class="headerlink" title="ThreadQuantum"></a>ThreadQuantum</h3><p>当一个新的线程开始执行时，初始化程序会在KTHREAD.Quantum赋初始值，该值的大小由KPROCESS.ThreadQuantum决定<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-37-53-e8e91a01e1158c2680d32c3bd60fa125-threadQuantum-7070a5.png"><br>随机选择一个进程查看，发现ThreadQuantum的值为6。这个值，就是<strong>该进程的线程执行时的CPU时间片</strong>。那如何使用这个值呢？我们接下来继续看。</p>
<h3 id="分析KeUpdateRunTime"><a href="#分析KeUpdateRunTime" class="headerlink" title="分析KeUpdateRunTime"></a>分析KeUpdateRunTime</h3><p>每次时钟中断发生时都<strong>会先调用KeUpdateRunTime函数</strong>，我们来看看这个函数干了什么事<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-38-27-a20a2355aa12a0ebb2f2c8c5e0ce9b82-kurt1-9959f7.png"><br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-38-44-67e725f679b8ba67f3e003d0fce135b3-kurt2-c7e585.png"><br>结合两张图来看，ebx保存的是<strong>当前线程的KTHREAD</strong>，接着将当前线程的Quantum的值-3。这下就清晰一些了，前面说了，一个线程初始的Quantum值为6，这里<strong>将Quantum的值 减了3</strong>。然后还做了什么呢，根据上面的信息，可以得知eax保存的KPCR，下面有一个逻辑判断，如果减3后值不为0，这里程序就跳转了，<strong>但是如果为0，此时程序会给KPCR+0x9AC处（QuantumEnd)的值赋上一个不为0的值</strong>，这个操作有什么用呢？往后看就知道了。</p>
<h3 id="分析KiDispatchInterrupt"><a href="#分析KiDispatchInterrupt" class="headerlink" title="分析KiDispatchInterrupt"></a>分析KiDispatchInterrupt</h3><p>这里小盆友可能会奇怪了，为什么突然就从KeUpdateRunTime就跳到这了呢？这里需要说明一下，KeUpdateRumTime函数，是每次时钟中断发生时都会调用的函数，这个函数做了两件事：</p>
<ol>
<li>将当前<strong>线程的KTHREAD.Quantum的值减3</strong></li>
<li>若Quantum的值减到了0，则会<strong>将KPCR.QuantumEnd的值置为一个不为0的数</strong></li>
</ol>
<p>之后这个函数就执行完了，接着，就是我们上一篇分析过的，时钟中断的执行流程，最终，在进行线程切换之前，会执行到KiDispatchInterrupt函数，接下来，就来看看刚刚修改过的两个值，和这个函数有何关系：</p>
<ol>
<li>进入KiDispatchInterrupt函数，这里有一个判断，稍作分析<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-40-40-0f427a45aef76d2276b4a49aca5eb2db-kdi1-20ae06.png"><br>这里的ebx存着的是KPCR，然后程序会去<strong>判断KPCR.QuantumEnd处的值是否为0</strong>，如果不是0，说明时间片走完了，<strong>也就是KTHREAD.Quantum值被减为0了</strong>，这是就会进行跳转，图中会跳转到loc_404902的位置</li>
<li>跟到loc_404902的位置继续观察<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-41-11-210831ef72dd38e48426bfd2ce8b8f13-kdi2-98b90b.png"><br>这里先<strong>将KPCR.QuantumEnd的值置零</strong>，然后跳转到KiQuantumEnd函数中继续执行（为什么先赋值，再清零呢？因为已经判断过了，已经跳转到这里了，将QuantumEnd的值置零，也是为了下一个执行的线程)</li>
<li>好，进入KiQuantumEnd函数<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-41-49-7a9f2410f0480ff84a297a40ed08cc75-kqe1-2abab6.png"><br>具体细节看图，这部分，主要是重新<strong>设置了当前这个线程的CPU时间片的值为ThreadQuantum</strong>。接着往下看<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-42-02-735db5a4661c813390ea8d815f188775-kqe2-62104d.png"><br>然后这个函数调用了KiFindReadyThread函数，在就绪队列中找到一个线程，接着就返回了</li>
<li>执行完KiQuantumEnd函数后，我们又回到了KiDispatchInterrupt函数<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-42-34-1f42f4998e434a813c7e798bd9452536-kdi3-08383c.png"><br>如果刚刚在KiFindReadyThread可以在就绪队列中找到一个线程，那么eax的值就不为空，如图，接下来会跳转到loc_4048BB的位置</li>
<li>接着看4048BB的位置<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-42-47-a127e25b6215a539091e8ba6d9e20d54-kdi4-121bd3.png"><br>看到了我们熟悉的线程切换函数</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>通过分析KeUpdateRunTime和KiDispatchInterrupt函数，我们可以发现。在CPU时间片用完的情况下，当时钟中断发生时，会发生线程的切换，这里做个小结：</p>
<ul>
<li>当一个新的线程开始执行时，初始化程序会<strong>在KTHREAD.Quantum赋初始值</strong>，该值的<strong>大小由KPRCOESS.ThreadQuantum决定</strong></li>
<li>每次时钟中断会调用KeUpdateRunTime函数，该函数每次将当前线程Quantum减少3个单，如果减到0，则将KPCR.PrcbData.QuantumEnd的值<strong>设置为非0</strong></li>
<li>KiDispatchInterrupt判断<strong>时间片到期后</strong>，<strong>调用KiQuantumEnd函数</strong>（重新设置时间片、找到要运行的线程）</li>
</ul>
<h2 id="备用线程"><a href="#备用线程" class="headerlink" title="备用线程"></a>备用线程</h2><p>这里我们直接定位到KiDispatchInterrupt的位置，看图<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-36-55-f97b7a3a8b247e7685b76222b1e33d46-kdi5-34abff.png"><br>可以发现，这是刚刚判断时间片是否到期的位置，这里共有两个判断：</p>
<ol>
<li>若CPU时间片<strong>到期</strong>（即KPCR.QuantumEnd的<strong>值为非0</strong>），<strong>则跳转</strong>，否则继续执行</li>
<li>若存在备用线程，则将备用线程取出。啥是备用线程呢？就是KPCR+0x128的位置，该处成员名称叫做NextThread，是一个KTHREAD结构。如果这个位置的值不为0，那么程序会继续执行</li>
</ol>
<p>后面的事情，看图片也就知道了。取出备用线程后，会先<strong>将当前线程放入就绪链表</strong>。这里为什么不放入等待链表呢？因为该线程处于就绪状态，只是在<strong>时钟中断发生时</strong>CPU时间片走完了或者存在备用线程，所以不会放入等待链表中。</p>
<p>当然。如果两个判断都没有执行，程序会直接跳到最后，返回了，也就是不发生线程切换<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-37-14-f93a414e76e290d12e8d3ce1be45d509-kdi6-d1d259.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>当前线程<strong>主动调用</strong>API：</p>
<p>KiSwapThread -&gt; KiSwapContext -&gt; SwapContext</p>
</li>
<li><p>当前线程<strong>时间片到期</strong>：<br>KiDispatchInterrupt -&gt; KiQuantumEnd -&gt; SwapContext</p>
</li>
<li><p><strong>存在备用线程</strong>：<br>KiDispatchInterrupt -&gt; SwapContext</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows线程切换</title>
    <url>/2022/04/03/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/Windows%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一篇介绍了一份模拟线程切换代码，通过对代码的分析和学习，我们知道了<strong>线程切换的本质就是堆栈的切换</strong>，其中有一个非常关键的函数：<strong>SwitchContext</strong>，当调用这个函数时，就会导致线程切换。同样，Windows也有一个用于线程切换的函数：<strong>KiSwapContext</strong></p>
<h2 id="KiSwapContext分析"><a href="#KiSwapContext分析" class="headerlink" title="KiSwapContext分析"></a>KiSwapContext分析</h2><p>我们先从这个函数开始说起，当然，相比模拟线程切换的代码，Windows中切换线程的代码更为复杂，但本质还是一样的，这里不作详细分析，分析关键函数，找到KiSwapContext的核心实现。</p>
<ol>
<li>首先定位到KiSwapContext<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-49-50-36208f44243c436fd8457e2a023d88bb-kiSwapContext-e75f15.png"><br>根据这几步，我们发现，外层函数传来了一个未知的参数ecx</li>
<li>我们跟进调用KiSwapContext的KiSwapThread<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-50-24-524fd486501f5a19bffd26e7a6f07a3c-kstCallksc-57d86b.png"></li>
<li>分析调用KiSwapContext的代码<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-51-40-7d1f1d869307ade6334e4faa3f7ff1cb-kiSwapThread-44145e.png"><br>可以发现，ecx的值，来源于KiFindReadyThread的返回值，顾名思义，这是一个<strong>在就绪队列中查找线程的函数</strong>，因此返回值应为一个KTHREAD</li>
<li>有了上面几步的分析，再回来看，就好理解了<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-52-37-08ca3bc4d5cc07ec515919e51e64a4d6-kiSwapContext2-f4cf33.png"><br>这几步的含义是，先把当前运行的线程取出到edi中，然后将刚刚从就绪队列中取出来的线程，放到KPCR中。我们可以看到，目前esi，edi，分别存放了切换后将执行的线程和正在执行的线程，但这里没有实现，需要进一步跟进SwapContext函数。</li>
<li>进入SwapContext函数后，忽略细节，我们可以很快找到线程切换最精髓的两条语句<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-19-53-23-bfbeae342fef6bb83a0e27fab304fd2f-swapContext-9ef3e7.png"><br><strong>堆栈切换</strong>，回忆一下，上一篇模拟线程切换的程序里，线程切换最关键的两条语句也是这样的原理，<strong>将esp保存到原线程的KernelStack中，并将新线程的KernelStack的值赋给esp，从而实现堆栈的切换，这也就是线程切换的本质</strong>。</li>
</ol>
<h2 id="主动切换"><a href="#主动切换" class="headerlink" title="主动切换"></a>主动切换</h2><h4 id="函数调用过程"><a href="#函数调用过程" class="headerlink" title="函数调用过程"></a>函数调用过程</h4><p>在分析完KiSwapContext函数后，我们可以总结出这样一个调用过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">KiSwapThread -&gt; KiSwapContext -&gt; SwapContext(内部实现线程切换)</span><br></pre></td></tr></table></figure>

<p>虽然，真正的切换是SwapContext函数实现的，但是经过分析，从KiSwapThread到KiSwapContext再到SwapContext是一个顺序执行的过程。所以我们可以认为，<strong>凡是调用了KiSwapThread函数，就一定会触发线程切换</strong>。</p>
<ul>
<li>在IDA中查看KiSwapThread的交叉引用表<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-24-00-9ba109e51637d5d12269df353353b592-kstXref-d65b1f.png"><br>我们可以看到，一共有<strong>7个函数调用了KiSwapThread</strong>函数，说明<strong>执行这些函数时，都会发生线程切换</strong></li>
<li>随机选取其中一个调用KiSwapThread的函数：KeWaitForSingleObject，查看KeWaitForSingleObject的交叉引用表<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-25-23-72df135ade99ffbed2c4b51834d5fd6e-kwfsoXref-ba3084.png"><br>可以看到有很多函数都调用了KeWaitForSingleObject，这也意味着这些函数在执行时，都会发生线程切换，因为它们最终都会调用SwapContext函数</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>我们可以看到，Windows中绝大部分API都会直接或间接调用SwapContext这个函数，也就是说，只要调用这些API函数，就会发生线程切换，这种通过<strong>调用API函数导致的线程切换叫做主动切换。</strong></p>
<h2 id="时钟中断切换"><a href="#时钟中断切换" class="headerlink" title="时钟中断切换"></a>时钟中断切换</h2><p>上面介绍了主动切换，需要依赖对系统API函数的调用才能触发。那么，如果不去主动调用系统API函数，该如何触发线程切换呢？这里介绍另一个导致线程切换的方式，通过<strong>时钟中断</strong>。</p>
<p>为何要采用时钟中断的方式呢？实际上我们在切换线程时，必须先让当前执行的线程停下来，保存了线程当前的环境后，再去切换线程。线程的暂停也意味着程序的暂停。那么，如何中断一个正在执行的程序呢？</p>
<ol>
<li><strong>异常</strong>：例如缺页异常或者INT N指令</li>
<li><strong>中断</strong>：例如时钟中断</li>
</ol>
<h3 id="系统时钟"><a href="#系统时钟" class="headerlink" title="系统时钟"></a>系统时钟</h3><table>
<thead>
<tr>
<th>（IDT表）中断号</th>
<th>IRQ</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x30</td>
<td>IRQ0</td>
<td>时钟中断</td>
</tr>
</tbody></table>
<ul>
<li>在Windows操作系统中，每10~20毫秒便会触发一次时钟中断</li>
<li>想要获取当前版本Windows时钟间隔值，可使用Win32API：GetSystemTimeAdjustment</li>
</ul>
<h3 id="时钟中断的执行流程"><a href="#时钟中断的执行流程" class="headerlink" title="时钟中断的执行流程"></a>时钟中断的执行流程</h3><p>进入IDA，我们一起来分析一下时钟中断的执行流程</p>
<ol>
<li><p>Alt+T 搜索_IDT，找到IDT表<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-26-19-84d55a25ab7be9bd7354708836893347-idt-af338e.png">](ht</p>
</li>
<li><p>之前中断门进0环学习过，int 2e执行的是KiSystemService，而时钟中断是int 30，所以我们可以很快定位它的中断例程是KiStartUnexpectedRange()<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-26-02-3152b9648123d2be6864f165660aaf11-int30-1fa321.png"></p>
</li>
<li><p>进入KiStartUnexpectedRange<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-27-16-5b4dd358bc194eda43827b18c7a88a30-ksur-7ad99c.png"><br>发现里面跳转到了KiEndUnexpectedRange函数</p>
</li>
<li><p>继续跟进KiEndUnexpectedRange<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-30-00-c263e1bb2b84cb3131a2b09ccfdd2599-keur-68ab63.png"><br>内部跳转到函数KiUnexpectedInterruptTail</p>
</li>
<li><p>进入KiUnexpectedInterruptTail内部<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-30-16-a3facb3812e88133e7e9c1d71910b760-kuit-6c7c45.png"></p>
<p>在这个函数结束前，我们可以看到，它调用了一个外部函数HalEndSystemInterrupt，在导入表中可以看到，这个外部函数位于HAL.dll<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-30-43-aa7bcd04c5a5b61505b1b75833c7d4eb-halDll-1aa6b5.png"></p>
</li>
<li><p>用IDA打开hal.dll，找到HalEndSystemInterrupt继续分析，这个函数不大，一眼看完就可以发现，它又调用了一个外部函数KiDispatchInterrupt<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-31-58-e47888c2655b9bf5db89430681819360-2022-08-14-20-31-01-e47888c2655b9bf5db89430681819360-hesi-f62210-485e6e.png"><br>我们再次进入导入表查看<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-32-33-d39ef43ea8f05d379859e72f1bcf5190-ntoskrnlDll-a397ca.png"><br>巧了嘛！这个函数是ntoskrnl的，又调回去了。。。</p>
</li>
<li><p>我们进入KiDispatchInterrupt康康<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-34-12-6427508fe320a0ee9a0e2e6aaeb82b2e-kdi-52168c.png"><br>哦吼，我们发现了什么？这不是就是<strong>SwapContext</strong>嘛！就是线程切换函数！</p>
</li>
<li><p>经过这么多步，终于找到了关键的函数，这里简单梳理一下流程<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-33-30-b9ff75638384fef316f040edab9d0314-flow-c11b6e.png"></p>
</li>
</ol>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>分析完时钟中断的执行流程可以发现，时钟中断最终会执行SwapContext函数，同样会发生线程切换。</p>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>还有一种导致线程切换的就是异常处理了。当程序发生异常时，会根据中断号，跳转到相应中断处理例程进行处理，也会导致线程的切换，这里不作详细分析了。具体的可以参考<a href="https://happy1wawayu.github.io/2022/03/16/%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/%E4%BB%BB%E5%8A%A1%E6%AE%B5/#%E8%A6%81%E7%82%B9%E5%9B%9E%E9%A1%BE">任务段</a>这篇通过TSS模拟实现进程切换。本质同样是堆栈的切换。</p>
<h2 id="关于进程切换"><a href="#关于进程切换" class="headerlink" title="关于进程切换"></a>关于进程切换</h2><p>本质上，<strong>进程的切换就是线程的切换</strong>，所以并不存在真正意义上进程的切换，与普通线程的切换相比，进程的切换仅仅是，两个线程不属于同一进程。因此在线程切换的过程中，Cr3换了，从而进程也就换了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>如果一个线程<strong>不调用API</strong>，并且在代码中<strong>屏蔽中断</strong>（通过CLI指令），并且程序<strong>不会出现异常</strong>，那么当前线程将永久占有CPU（单核CPU占用率100%，2核CPU占用率50%）</li>
<li>Windows并且是“抢占式”操作系统，所谓的“抢“<strong>必须是当前线程允许其它线程</strong>“抢”，否则是“抢”不到的</li>
</ol>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程优先级</title>
    <url>/2022/04/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面分析过了SwapContext函数，用来线程切换的；<strong>线程切换需要2个线程</strong>，一个是<strong>当前线程</strong>，一个是<strong>用来切换的目标线程</strong>，我们知道<strong>当前线程可以通过KPCR+0x124位置的CurrentThread获得</strong>，那么目标线程该如何获得呢？下面一块来研究一下</p>
<h2 id="线程切换的方式"><a href="#线程切换的方式" class="headerlink" title="线程切换的方式"></a>线程切换的方式</h2><p>先回顾一下线程切换三种方式的过程：</p>
<ol>
<li><p>当前线程<strong>主动调用API</strong>：</p>
<p>API函数 -&gt; KiSwapThread -&gt; KiSwapContext -&gt; SwapContext</p>
</li>
<li><p>当前线程<strong>时间片到期</strong>：</p>
<p>KiDipatchInterrupt -&gt; KiQuantumEnd -&gt; SwapContext</p>
</li>
<li><p>KPCR中存<strong>有备用线程</strong>：</p>
<p>KiDispatchInterrupt -&gt; SwapContext</p>
</li>
</ol>
<p>在<strong>有备用线程</strong>的条件下，SwapContext的目标线程参数可以通过(KPCR.PrcbData.NextThread)直接取出。那么另外两种方式，是如何找到下一个要切换的线程呢？</p>
<ul>
<li>先看<strong>主动调用API</strong>的方式，进入IDA分析一下KiSwapContext函数执行之前的流程<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-59-48-b23747cf33861a3b9816f8067f05dcef-kst-8b4f60.png"><br>由图，我们可以看出，KiSwapThread函数内，会<strong>先执行KiFindReadyThread</strong>取出<strong>目标线程</strong>，之后<strong>再执行KiSwapContext</strong>函数的</li>
<li>再看<strong>时间片到期</strong>的方式，我们进入KiQuantumEnd进行分析<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-58-12-b7912e33bffd58f8b879c42c6f825cfa-kqe-b43f70.png"><br>可以发现，KiQuantumEnd内部，也会先执行KiFindReadyThread函数，返回一个线程结构体</li>
</ul>
<p>通过分析可以得知，线程切换的目标线程，与KiFindReadyThread有关，接下来就结合KiFindReadyThread函数来分析一下如何获取目标线程。</p>
<h2 id="线程查找"><a href="#线程查找" class="headerlink" title="线程查找"></a>线程查找</h2><p>在分析查找线程之前，我们先来回顾一下之前学习的<a href="https://happy1wawayu.github.io/2022/04/01/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E7%AD%89%E5%BE%85%E9%93%BE%E8%A1%A8&%E8%B0%83%E5%BA%A6%E9%93%BE%E8%A1%A8/">调度链表</a>的知识<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-58-12-6a19d58482b1183916cb4fed8bdd2664-kdrlh-fe75d4.png"><br>调度链表共32个，如果说一个线程，它满足运行条件了，就会被扔到这个链表里面(<strong>根据优先级</strong>)，也就是说，<strong>线程切换的时候</strong>，就是<strong>从这个调度链表里面找</strong>一个线程出来，而KiFindReadyThread函数就是干这事的。</p>
<h3 id="KiFindReadyThread查找方式"><a href="#KiFindReadyThread查找方式" class="headerlink" title="KiFindReadyThread查找方式"></a>KiFindReadyThread查找方式</h3><p>这个函数的查找方式非常简单暴力，会按照优先级别进行查找：31..30..29..28</p>
<p>换句话说，在<strong>本次查找</strong>中，<strong>如果级别31的链表里面有线程</strong>，那么就不会查找级别为30的链表，直接从级别31的链表里取一个出来</p>
<h3 id="如何高效查找"><a href="#如何高效查找" class="headerlink" title="如何高效查找"></a>如何高效查找</h3><p>调度链表有32个，如果每次都从开始查找效率就太低了，因此Windows通过一个DWORD类型的变量来记录：</p>
<p>当向<strong>调度链表（32个）中挂入或者摘除某个线程时</strong>，会<strong>判断当前级别的链表是否为空</strong>，会判断当前级别的链表是否为空，为空则将DWORD变量（_KiReadySummary）对应位置0，否则置1。大致如下图：<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-58-12-06c2cef3b52f2f742c87d29e075a1e8c-krs-fb175c.png"><br>多CPU下会随机寻找KiDispatcherReadyListHead指向的数组中的线程。线程可以绑定某个CPU（使用API：setThreadAffinityMask)</p>
<h3 id="如果没有就绪线程怎么办"><a href="#如果没有就绪线程怎么办" class="headerlink" title="如果没有就绪线程怎么办"></a>如果没有就绪线程怎么办</h3><p>这里我们先了解一下如何看调度链表<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-04-56-07ad8017c34559a59e51829137623a83-null-97b16c.png"></p>
<p>大致分三种情况：</p>
<ol>
<li><strong>双向链表的值一样</strong>，<strong>且等于当前地址</strong>，说明该链表是空的</li>
<li><strong>双向链表的值一样</strong>，但是<strong>不等于当前地址</strong>，说明该链表只有一个线程</li>
<li><strong>双向链表的值不一样</strong>，说明链表中存在2个或者2个以上个线程</li>
</ol>
<p>那么，如果32个调度链表都是空的怎么办？</p>
<p>我们来进入IDA看一下执行流程：</p>
<ol>
<li>查看KiFindReadyThread执行后的代码<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-58-12-d5e1cc09e80b804337f8d068717baa14-jmp-101afe.png" alt="img"><br>若eax值为空（即<strong>没有取到线程</strong>)那么会跳转到loc_8000EA85的位置执行</li>
<li>来看看loc_8000EA85处做了什么<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-20-58-13-135c9d481413ae5c15634bece9a5ecf9-idle-25c496.png"><br>实际上只做了一件事，就是给eax赋值，因为KiFindReadyThread函数没有找到就绪线程，因此eax值是空的，这里<strong>给eax赋的值</strong>，就<strong>是KPCR.PrcbData.IdleThread</strong>。也就是KPCR中存着的空闲线程</li>
</ol>
<p>这下我们弄明白了，<strong>如果就绪链表中没有线程</strong>，那么发生<strong>线程切换时</strong>，会<strong>切换到一个Idle线程</strong>继续执行，从而保证CPU一直稳定的执行</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>进程挂靠</title>
    <url>/2022/04/06/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E8%BF%9B%E7%A8%8B%E6%8C%82%E9%9D%A0/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学习进程挂靠之前，先回顾一下进程与线程相关的知识</p>
<h2 id="进程与线程的关系"><a href="#进程与线程的关系" class="headerlink" title="进程与线程的关系"></a>进程与线程的关系</h2><h3 id="基本关系"><a href="#基本关系" class="headerlink" title="基本关系"></a>基本关系</h3><ul>
<li>一个进程<strong>可以包含多个线程</strong></li>
<li>一个进程<strong>至少要有一个线程</strong></li>
</ul>
<p><strong>进程</strong>为线程提供资源，也就是<strong>提供Cr3</strong>的值，Cr3中存储的是页目录表基址，Cr3确定了，线程能访问的内存也就确定了。</p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>来看这样一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov eax,dword ptr ds:[0x12345678]</span><br></pre></td></tr></table></figure>

<p>CPU如何解析0x12345678这个地址呢？</p>
<ol>
<li>CPU解析线性地址时，需要通过<strong>页目录表（PDT）</strong>来找到对应的物理页，页目录表基址存在Cr3寄存器中，这些都是保护模式的内容，已经很熟悉了</li>
<li>当前的Cr3的值来源于当前的进程（_KPROCESS.DirectoryTableBase(+0x018)）<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-07-53-7c601add397b7380735877d1eba449e9-dtb-52ea14.png"></li>
</ol>
<h3 id="线程找进程"><a href="#线程找进程" class="headerlink" title="线程找进程"></a>线程找进程</h3><p>线程找进程有两种情况：<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-09-19-f41925736c717f1d2ca9a69687178f4a-threadFindProcess-5b0a00.png"></p>
<ol>
<li><strong>KHTREAD.ApcState.Process</strong>(+0x44)</li>
<li><strong>ETHREAD.ThreadProcess</strong>(+0x220)</li>
</ol>
<p>所以，从KTHREAD以及ETHREAD均能找到当前线程的进程，这里引用海哥的叫法，把KTHREAD找到的Process(+0x44)叫做<strong>养父母</strong>，把ETHREAD找到的ThreadProcess(+0x220)叫做<strong>亲生父母</strong></p>
<h3 id="养父母负责提供Cr3"><a href="#养父母负责提供Cr3" class="headerlink" title="养父母负责提供Cr3"></a>养父母负责提供Cr3</h3><p>线程切换的时候，会<strong>比较KTHREAD结构体0x044处指定的EPROCESS</strong>是否为同一个，如果不是同一个，会将0x044处指定的EPROCESS的DirectoryTableBase的值取出，赋值给Cr3。这部分在分析SwapContext的<a href="https://happy1wawayu.github.io/2022/04/05/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E5%88%86%E6%9E%90SwapContext/#Part3">Part3</a>部分提到过，这里不多赘述。可以跳转或者参考下图的紫色部分<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-07-54-c78d63e314424d2885cfc3b0e97e5db7-part3-ff4ddf.png"></p>
<p>所以，<strong>线程所需要的Cr3</strong>的值，<strong>来源于0x044偏移处</strong>指定的EPROCESS，所以得出如下结论：</p>
<ul>
<li>0x220：亲生父母，这个线程谁创建的</li>
<li>0x044：养父母，谁在为这个线程提供资源（也就提供Cr3）。一般情况下，0x220与0x044指向的是<strong>同一个进程</strong></li>
</ul>
<h2 id="进程挂靠"><a href="#进程挂靠" class="headerlink" title="进程挂靠"></a>进程挂靠</h2><p>有了上述概念后，我们知道了，正常情况下，Cr3的值是由养父母提供的，但是Cr3的值也可以改成和当前线程毫不相干的其它进程的DirectoryTableBase。</p>
<p>观察下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cr3,A.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		; A进程的0x12345678内存</span><br><span class="line">mov cr3,B.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		; B进程的0x12345678内存</span><br><span class="line">mov cr3,C.DirectoryTableBase</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]		; C进程的0x12345678内存</span><br></pre></td></tr></table></figure>

<p>将当前Cr3的值改为其它进程，称为“<strong>进程挂靠</strong>”。</p>
<p>进程挂靠存在的意义是什么呢，上面的代码，分别将不同进程的DirectoryTableBase的值写入Cr3。这时，每次读入的0x12345678这个线性地址上的值，分别<strong>是对应进程上0x12345678线性地址所对应物理页的内容</strong>。有了进程挂靠，就意味着可以读取其它进程的内存。</p>
<h2 id="分析NtReadVirtualMemory"><a href="#分析NtReadVirtualMemory" class="headerlink" title="分析NtReadVirtualMemory"></a>分析NtReadVirtualMemory</h2><p>我们知道，ReadProcessMemory这个三环API是可以读取其它进程的内存的，该函数在0环的实现是NtReadVirtualMemory，来分析一下这个函数，看看它是如何读取其它进程内存的：</p>
<ol>
<li><p>首先，进入NtReadVirtualMemory，由于这个函数非常复杂，就直接挑重点来说了<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-07-54-f71844e5c08d5102f85d0de0b47e2f84-nrvm-81855d.png"><br>这里调用了一个_MmCopyVirtualMemory函数，看名字就感觉，这个和别的进程的内存可能有点关系，毕竟是Copy来的….</p>
</li>
<li><p>进入_MmCopyVirtualMemory继续查看<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-11-01-ddd355a5a6beb7bb853b7544f4c20ee8-mcvm-246a22.png">]<br>这个函数不大，有一个函数很关键MiDoPoolCopy，这个函数Push了一大堆参数，内部应该实现了重要的功能，继续更近</p>
</li>
<li><p>跟进_MiDoPoolCopy函数<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-07-54-ccc4a9f3800dc62f01bb7903935fbfd2-mdpc-b10b2f.png">]<br>往下翻，有一个KeStackAttachProcess，由名字可知，这个函数和进程挂靠有关</p>
</li>
<li><p>再进一步，进入_KeStackAttachProcess函数<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-12-01-2f992e5cffd1c53aec3b9717dfdfb3fb-ksap-87b55b.png"><br>看到这里，就是真正的挂靠函数，进入分析看看Windows到底是如何实现进程挂靠的</p>
</li>
<li><p>直接看图<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-12-18-b0d92abf89927dbad6b94ae31eecead4-kap-8f4d7d.png"><br>这里面进行了两个主要的操作：</p>
<p>1）修改<strong>养父母</strong>，即KTHREAD.ApcState.Process的值，修改为将要访问的进程的<strong>进程结构体</strong></p>
<p>2）调用进程切换函数KiSwapProcess（<strong>本质是切换Cr3</strong>）</p>
</li>
<li><p>进入<strong>KiSwapProcess</strong>看看这个函数具体做了什么<br><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-07-55-4715b1099d803c9f73dd00e110805b33-ksp-618e18.png"></p>
<p>来看最关键的部分，KiSwapProcess函数，先从外部参数，获取到了将要访问的进程的Cr3，然后分别<strong>修改TSS.Cr3和KPROCESS+0x18（DirectoryTableBase)处的值</strong>，然后便完成了进程切换。可以发现，进程切换，实际上就是切换了Cr3</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>简要分析完了NtReadVirtualMemory函数后可以发现，这个函数主要做了两件事，第一件事，<strong>修改线程养父母</strong>，第二件事，<strong>修改进程Cr3</strong>。随后就可以访问和读取另一个进程的内存了。</p>
<p>那么小盆友要问了，可不可以只修改Cr3，而不修改养父母呢？当然是不可以的，如果不修改养父母的值，一旦发生线程切换，再切回来的时候，<strong>读取的内存，是由养父母提供的Cr3，而养父母没有修改，因此读取的还是自己线程所在的进程</strong>，即变成了自己读自己了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>正常情况下，当前线程使用的<strong>Cr3是由其所属进程提供的</strong>（KTHREAD+0x44偏移处指定的EPROCESS），正是因为如此，A进程中的线程只能访问A的内存。</p>
<p>如果要让<strong>A进程中的线程能够访问B进程的内存</strong>，就必须<strong>要修改Cr3的值为B进程的页目录表基址</strong>（B.DirectoryTableBase），这就是所谓的“<strong>进程挂靠</strong>”</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title>跨进程读写内存</title>
    <url>/2022/04/07/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/%E8%B7%A8%E8%BF%9B%E7%A8%8B%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="要点回顾"><a href="#要点回顾" class="headerlink" title="要点回顾"></a>要点回顾</h2><p>跨进程的本质是“<strong>进程挂靠</strong>”，正常情况下，A进程的线程只能访问A进程的地址空间，如果A进程的线程想访问B进程的地址空间，就要修改当前的Cr3的值为B进程的页目录表基址（KPROCESS.DirectoryTableBase）</p>
<p>即：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cr3, B.DirectoryTableBase</span><br></pre></td></tr></table></figure>

<h2 id="跨进程操作"><a href="#跨进程操作" class="headerlink" title="跨进程操作"></a>跨进程操作</h2><p>A进程中的线程代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mov cr3,B.DirectoryTableBase		; 切换Cr3的值为B进程</span><br><span class="line">mov eax,dword ptr ds:[0x12345678]	; 将进程B 0x12345678的值存的eax中</span><br><span class="line">mov dword ptr ds:[0x00401234],eax	; 将数据存储到0x00401234中</span><br><span class="line">mov cr3,A.DirectoryTableBase		; 切换回Cr3的值</span><br></pre></td></tr></table></figure>

<p>这是一个模拟跨进程读写内存的操作，但是代码实际上是存在问题的。代码中，将数据写入到0x00401234这个地址里，但<strong>这个地址是位于B进程地址空间的</strong>，因此A进程中是无法读出来这个值的。那该如何读写另一个进程的内存呢？</p>
<p>之前，在学习保护模式内容的时候，发现不同进程低2G对应的物理页往往是不同的，但是高2G对应的物理页往往是相同的。可以利用这一点，可以先将数据暂存到高2G的内存，然后切换到另一个进程中，进入读写操作。具体我们来参考一下NtReadVirtualMemory的实现理念。</p>
<h3 id="NtReadVirtualMemory流程"><a href="#NtReadVirtualMemory流程" class="headerlink" title="NtReadVirtualMemory流程"></a>NtReadVirtualMemory流程</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-21-16-ccc7f2d31a44777089c608966aec82b3-read-285f00.png"></p>
<h3 id="NtWriteVirtualMemory流程"><a href="#NtWriteVirtualMemory流程" class="headerlink" title="NtWriteVirtualMemory流程"></a>NtWriteVirtualMemory流程</h3><p><img src="https://raw.githubusercontent.com/happy1wawayu/MyPic/main/2022-08-14-21-21-16-6461c2edc53d02a51fae4d7b3ecb6308-write-444ff1.png"></p>
<p>通过分析这两个函数实现跨进程读写的原理可以发现，都是<strong>利用了进程高2G地址对应的物理页相同</strong>这个特性，先将数据暂存到高2G的位置，然后切换进程，再在另一个进程是进行读取操作。</p>
]]></content>
      <categories>
        <category>Windows内核</category>
      </categories>
      <tags>
        <tag>x86</tag>
        <tag>Windows内核</tag>
        <tag>进程与线程</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/09/17/%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91/%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
